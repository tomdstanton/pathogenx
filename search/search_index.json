{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PathoGenX \ud83e\udda0\ud83e\uddec\ud83d\uddfa\ufe0f","text":""},{"location":"#a-python-library-for-pathogen-genotype-exploration","title":"A Python library for Pathogen Genotype eXploration","text":"<p>[!WARNING] \ud83d\udea7 This package is currently under construction, proceed with caution \ud83d\udea7</p>"},{"location":"#introduction","title":"Introduction \ud83c\udf10","text":"<p><code>pathogenx</code> is a Python library for Pathogen Genotype eXploration. It started a Python port of the  KleborateR R code to parse  Kleborate and other data from Pathogenwatch, to calculate prevalence data for sero-epidemiology, and to provide a backend for our  neonatal sepsis sero-epi app.</p> <p><code>pathogenx</code> aims to be more generalised towards other bacterial genotyping and distance calculation methods, and will eventually force complicity with the  PHA4GE genotyping-specification.</p> <p><code>pathogenx</code> revolves around genotyping <code>Dataset</code> objects, which have the following attributes:</p> <ul> <li>Genotyping data - a <code>pandas</code> dataframe containing the parsed output of a genotyping tool. </li> <li>Optional metadata - joined to genotyping results upon initialisation, possibly containing spatio-temporal data.</li> <li>Optional distances - Represented as a <code>scipy.sparse</code> matrix of pairwise distances, parsed from the outputs of tools  such as <code>mash</code>.</li> </ul> <p>We also define <code>Calculator</code>s, which calculate informative information from genotyping data, such as prevalence and  diversity.</p>"},{"location":"#installation","title":"Installation \u2699\ufe0f","text":""},{"location":"#from-source","title":"From source:","text":"<pre><code>pip install git+https://github.com/tomdstanton/pathogenx.git\n</code></pre>"},{"location":"#usage","title":"Usage \ud83e\uddd1\u200d\ud83d\udcbb","text":"<p>The information below explains how to use the <code>pathogenx</code> CLI.  For API usage, please refer to the reference documentation.</p>"},{"location":"#prevalence","title":"Prevalence \ud83c\udf0e","text":"<p>The <code>PrevalenceCalculator</code> object to calculate prevalence from a dataset is exposed via the command-line. For more information about the calculator, please refer to the  API docs.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>To calculate prevalences from the  KlebNet neonatal sepsis collection, download Kleborate, metadata and distance matrix files from Pathogenwatch, then run the following:</p> <pre><code>pathogenx prevalence pw_kleborate.csv ST &gt; prevalence.tsv\npathogenx prevalence pw_kleborate.csv Country ST --metadata pw_metadata.csv &gt; prevalence_by_country.tsv\npathogenx prevalence pw_kleborate.csv K_locus --distances pw_distances.csv --adjust-for Cluster &gt; adjusted_prevalence.tsv\n</code></pre>"},{"location":"#arguments","title":"Arguments","text":"<pre><code>usage: pathogenx prevalence &lt;genotypes&gt; &lt;strata&gt; [options]\n\n========================|&gt; PathoGenX |&gt;========================\n      A Python library for Pathogen Genotype eXploration       \n\nInputs:\n\n  &lt;genotypes&gt;          Genotype file\n  &lt;strata&gt;             List of columns to stratify the analysis by\n  --metadata []        Optional metadata file\n  --distances []       Optional distance file\n  --genotype-flavour   Genotype file flavour (default: pw-kleborate)\n                       (choices: kleborate, pw-kleborate, kaptive)\n  --metadata-flavour   Metadata file flavour (default: pw-metadata)\n                       (choices: pw-metadata)\n  --distance-flavour   Distance file flavour (default: pw-dist)\n                       (choices: mash, ska1, ska2, pw-dist)\n\nCalculator options:\n\n  --adjust-for [ ...]  Optional list of columns for adjustment (e.g., Cluster)\n  --n-distinct [ ...]  Optional list of columns to calculate distinct counts for\n  --denominator        Optional column to use as the primary grouping for denominators\n                       If None, the first column in stratify-by is used\n\nClustering options:\n\n  --snp-distance       The maximum distance for two samples to be considered connected.\n                       Only used when `method` is connected_components (default: 20)\n\nOther options:\n\n  -v, --version        Show version number and exit\n  -h, --help           Show this help message and exit\n</code></pre>"},{"location":"#web-app","title":"Web-app","text":"<p>The PathoGenX app provides a web-based GUI for the exploration of pathogen genotyping data. It is an optional module that can be installed and run with the following command:</p> <pre><code>pip install pathogenx[app]\npathogenx app\n</code></pre> <p>Read more about the app here.</p>"},{"location":"app/","title":"PathoGenX Web App","text":""},{"location":"app/#a-web-based-gui-for-pathogen-genotype-exploration","title":"A web-based GUI for pathogen genotype exploration","text":"<p>[!WARNING] \ud83d\udea7 This package is currently under construction, proceed with caution \ud83d\udea7</p>"},{"location":"app/#introduction","title":"Introduction","text":"<p>This app provides a web-based GUI for the exploration of pathogen genotyping data. This begun as a Python port of the R-Shiny app and backend R code for the Klebsiella Neonatal Sepsis Sero-epi app, but we generalised it for the exploration of different genotypes from multiple sources. You can read more about the <code>pathogenx</code> code here.</p>"},{"location":"app/#installation","title":"Installation","text":"<p>The app is an optional module under the <code>pathogenx</code> library and can therefore be installed with pip:</p> <pre><code>pip install pathogenx[app]\n</code></pre>"},{"location":"app/#usage","title":"Usage","text":"<p>We've exposed the app module via the PathoGenX CLI, and can be run in your browser with the following command:</p> <pre><code>pathogenx app\n</code></pre>"},{"location":"app/#arguments","title":"Arguments","text":"<pre><code>pathogenx app -h\nusage: pathogenx app [options]\n\n========================|&gt; PathoGenX |&gt;========================\n      A Python library for Pathogen Genotype eXploration       \n\nApp options:\n\n  Arguments to be passed to `shiny.run_app()`\n\n  --host              The address that the app should listen on (default: 127.0.0.1)\n  --port              The port that the app should listen on.\n                      Set to 0 to use a random port (default: 8000)\n  --autoreload-port   The port that should be used for an additional websocket that is used to\n                      support hot-reload. Set to 0 to use a random port (default: 0)\n  --reload            Enable auto-reload\n  --ws-max-size       WebSocket max size message in bytes (default: 16777216)\n  --launch-browser    Launch app browser after app starts, using the Python webbrowser module\n  --dev-mode          Run in development mode\n\nOther options:\n\n  -v, --version       Show version number and exit\n  -h, --help          Show this help message and exit\n</code></pre>"},{"location":"reference/pathogenx/","title":"pathogenx","text":"<p>Top-level module, including resource and optional dependency management.</p>"},{"location":"reference/pathogenx/#pathogenx.DependencyWarning","title":"<code>DependencyWarning</code>","text":"<p>               Bases: <code>PathogenxWarning</code></p> <p>Warning issued when an optional dependency is not found.</p> Source code in <code>pathogenx/__init__.py</code> <pre><code>class DependencyWarning(PathogenxWarning):\n    \"\"\"Warning issued when an optional dependency is not found.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/pathogenx/#pathogenx.PathogenxWarning","title":"<code>PathogenxWarning</code>","text":"<p>               Bases: <code>Warning</code></p> <p>Base warning class for the pathogenx package.</p> <p>This allows users to easily silence all warnings from this package.</p> <p>Examples:</p> <p>To ignore all warnings from this package:</p> <pre><code>&gt;&gt;&gt; import warnings\n&gt;&gt;&gt; from pathogenx import PathogenxWarning\n... warnings.simplefilter('ignore', PathogenxWarning)\n</code></pre> Source code in <code>pathogenx/__init__.py</code> <pre><code>class PathogenxWarning(Warning):\n    \"\"\"Base warning class for the pathogenx package.\n\n    This allows users to easily silence all warnings from this package.\n\n    Examples:\n        To ignore all warnings from this package:\n        &gt;&gt;&gt; import warnings\n        &gt;&gt;&gt; from pathogenx import PathogenxWarning\n        ... warnings.simplefilter('ignore', PathogenxWarning)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/pathogenx/#pathogenx.Resources","title":"<code>Resources</code>","text":"<p>Holds global resources for this package which are generated on demand.</p> <p>This class provides a centralized way to access package-level information like metadata and to check for the availability of optional dependencies. Resources are loaded lazily upon first access.</p> <p>Attributes:</p> Name Type Description <code>package</code> <code>str</code> <p>The name of the package.</p> <code>optional_packages</code> <code>set[str]</code> <p>A set of available optional packages.</p> Source code in <code>pathogenx/__init__.py</code> <pre><code>class Resources:\n    \"\"\"Holds global resources for this package which are generated on demand.\n\n    This class provides a centralized way to access package-level information\n    like metadata and to check for the availability of optional dependencies.\n    Resources are loaded lazily upon first access.\n\n    Attributes:\n        package (str): The name of the package.\n        optional_packages (set[str]): A set of available optional packages.\n    \"\"\"\n    def __init__(self, *optional_packages: str):\n        \"\"\"Initializes the Resources object.\n\n        Args:\n            *optional_packages: A variable number of optional package names to\n                check for availability (e.g., 'numpy', 'pandas').\n        \"\"\"\n        self.package: str = Path(__file__).parent.name\n        self.optional_packages: set[str] = set(filter(self._check_module, optional_packages))\n        self._metadata: 'PackageMetadata' = None  # Generated on demand\n\n    @property\n    def metadata(self) -&gt; 'PackageMetadata':\n        \"\"\"Package metadata.\n\n        Lazily loads and returns the package's metadata (e.g., version).\n\n        Returns:\n            PackageMetadata: The metadata object for the package.\n        \"\"\"\n        if self._metadata is None:\n            from importlib.metadata import metadata\n            self._metadata = metadata(self.package)\n        return self._metadata\n\n    @staticmethod\n    def _check_module(module_name: str) -&gt; bool:\n        \"\"\"Checks if a module can be imported.\n\n        Args:\n            module_name (str): The name of the module to check.\n\n        Returns:\n            bool: True if the module can be imported, False otherwise.\n        \"\"\"\n        try:\n            import_module(module_name)\n            return True\n        except ImportError:\n            return False\n</code></pre>"},{"location":"reference/pathogenx/#pathogenx.Resources.metadata","title":"<code>metadata</code>  <code>property</code>","text":"<p>Package metadata.</p> <p>Lazily loads and returns the package's metadata (e.g., version).</p> <p>Returns:</p> Name Type Description <code>PackageMetadata</code> <code>PackageMetadata</code> <p>The metadata object for the package.</p>"},{"location":"reference/pathogenx/#pathogenx.Resources.__init__","title":"<code>__init__(*optional_packages)</code>","text":"<p>Initializes the Resources object.</p> <p>Parameters:</p> Name Type Description Default <code>*optional_packages</code> <code>str</code> <p>A variable number of optional package names to check for availability (e.g., 'numpy', 'pandas').</p> <code>()</code> Source code in <code>pathogenx/__init__.py</code> <pre><code>def __init__(self, *optional_packages: str):\n    \"\"\"Initializes the Resources object.\n\n    Args:\n        *optional_packages: A variable number of optional package names to\n            check for availability (e.g., 'numpy', 'pandas').\n    \"\"\"\n    self.package: str = Path(__file__).parent.name\n    self.optional_packages: set[str] = set(filter(self._check_module, optional_packages))\n    self._metadata: 'PackageMetadata' = None  # Generated on demand\n</code></pre>"},{"location":"reference/pathogenx/#pathogenx.require","title":"<code>require(*packages)</code>","text":"<p>A decorator to verify optional dependencies before function execution.</p> <p>If any of the specified packages are not installed, this decorator will issue a <code>DependencyWarning</code> and prevent the decorated function from running.</p> <p>Parameters:</p> Name Type Description Default <code>*packages</code> <code>str</code> <p>The names of optional packages required by the function.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>The wrapped function, which will only execute if all dependencies are met.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathogenx import require\n...\n... @require('numpy', 'pandas')\n... def process_data_with_numpy_and_pandas(data):\n...     # This code will only run if numpy and pandas are installed\n...     pass\n</code></pre> Source code in <code>pathogenx/__init__.py</code> <pre><code>def require(*packages: str) -&gt; Callable:\n    \"\"\"A decorator to verify optional dependencies before function execution.\n\n    If any of the specified packages are not installed, this decorator will\n    issue a `DependencyWarning` and prevent the decorated function from\n    running.\n\n    Args:\n        *packages: The names of optional packages required by the function.\n\n    Returns:\n        Callable: The wrapped function, which will only execute if all\n            dependencies are met.\n\n    Examples:\n        &gt;&gt;&gt; from pathogenx import require\n        ...\n        ... @require('numpy', 'pandas')\n        ... def process_data_with_numpy_and_pandas(data):\n        ...     # This code will only run if numpy and pandas are installed\n        ...     pass\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            if missing_deps := [dep for dep in packages if dep not in RESOURCES.optional_packages]:\n                warn(\n                    f\"Function '{func.__name__}' requires the following missing dependencies: \"\n                    f\"{', '.join(missing_deps)}. Skipping execution.\",\n                    DependencyWarning\n                )\n                return None\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"reference/pathogenx/app/","title":"pathogenx.app","text":""},{"location":"reference/pathogenx/app/plotters/","title":"pathogenx.app.plotters","text":"<p>Module for generating interactive plots for <code>pathogenx.calculators.PrevalenceResult</code>s</p>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.CoveragePlotter","title":"<code>CoveragePlotter</code>","text":"<p>Creates an interactive plot to visualize cumulative coverage.</p> <p>This plot shows the cumulative proportion (coverage) of a target as more categories of a stratifying variable are included. It's useful for understanding how many unique genotypes, for example, are needed to cover a certain percentage of the population in different countries.</p> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>class CoveragePlotter:\n    \"\"\"\n    Creates an interactive plot to visualize cumulative coverage.\n\n    This plot shows the cumulative proportion (coverage) of a target as more\n    categories of a stratifying variable are included. It's useful for\n    understanding how many unique genotypes, for example, are needed to\n    cover a certain percentage of the population in different countries.\n    \"\"\"\n\n    def __init__(self, x_order: List[str] = None, max_x: int = 15, theme: dict = _THEME):\n        \"\"\"Initializes the CoveragePlotter.\n\n        Args:\n            x_order (List[str], optional): The order of categories on the x-axis.\n                Defaults to None, which orders by descending total count.\n            max_x (int, optional): The maximum number of x-axis categories to display.\n                Defaults to 15.\n            theme (dict, optional): A dictionary of Plotly layout settings. Defaults to _THEME.\n        \"\"\"\n        self.x_order = x_order\n        self.max_x = max_x\n        self.theme = theme\n\n    def plot(self, result: PrevalenceResult) -&gt; go.Figure:\n        \"\"\"Generates a cumulative coverage plot from a PrevalenceResult.\n\n        Args:\n            result (PrevalenceResult): The prevalence result, which must be stratified\n                by at least two columns and have a denominator.\n\n        Returns:\n            go.Figure: A Plotly figure object.\n\n        Raises:\n            ValueError: If the result is not stratified by at least two columns\n                or does not have a denominator.\n        \"\"\"\n        if not result.denominator or len(result.stratified_by) &lt; 2:\n            raise ValueError(\"CoveragePlotter requires results stratified by at least two columns with a denominator.\")\n\n        data = result.data\n        denominator_col = result.denominator\n        x_col = next(c for c in result.stratified_by if c != denominator_col)\n\n        # Determine X-axis order\n        if self.x_order:\n            x_order = self.x_order\n        else:\n            # Default to ordering by total count across all denominators\n            x_order = data.groupby(x_col)['count.raw'].sum().sort_values(ascending=False).index.tolist()\n\n        if self.max_x and len(x_order) &gt; self.max_x:\n            x_order = x_order[:self.max_x]\n\n        # Prepare data for plotting by creating all combinations\n        plot_data = (\n            data.set_index([denominator_col, x_col])\n            .reindex(\n                pd.MultiIndex.from_product([data[denominator_col].unique(), x_order], names=[denominator_col, x_col]))\n            .fillna(0)\n            .reset_index()\n        )\n\n        # Set the custom sort order for the x-axis column and then sort\n        plot_data[x_col] = pd.Categorical(plot_data[x_col], categories=x_order, ordered=True)\n        plot_data = plot_data.sort_values(by=[denominator_col, x_col])\n\n        # Calculate cumulative values within each denominator group\n        grouped = plot_data.groupby(denominator_col, sort=False)\n        plot_data['cum_prop'] = grouped['prop.raw'].cumsum()\n        plot_data['se_squared'] = plot_data['se.raw'] ** 2\n        # The error of a sum of proportions is complex. We approximate the\n        # cumulative error by summing the individual standard errors in quadrature.\n        plot_data['cum_se'] = np.sqrt(grouped['se_squared'].cumsum())\n\n        z = norm.ppf(1 - (0.05 / 2))\n        plot_data['cum_lower'] = (plot_data['cum_prop'] - z * plot_data['cum_se']).clip(0, 1)\n        plot_data['cum_upper'] = (plot_data['cum_prop'] + z * plot_data['cum_se']).clip(0, 1)\n\n        # Create hover text\n        hover_text = (\n                f\"&lt;b&gt;{x_col}&lt;/b&gt;: \" + plot_data[x_col].astype(str) +\n                f\"&lt;br&gt;&lt;b&gt;{denominator_col}&lt;/b&gt;: \" + plot_data[denominator_col].astype(str) +\n                \"&lt;br&gt;Individual Prop: \" + plot_data['prop.raw'].map('{:.3f}'.format) +\n                \"&lt;br&gt;Cumulative Prop: \" + plot_data['cum_prop'].map('{:.3f}'.format)\n        )\n\n        fig = go.Figure()\n        for name, group in plot_data.groupby(denominator_col):\n            fig.add_trace(go.Scatter(\n                x=group[x_col], y=group['cum_prop'], name=name,\n                mode='lines+markers', text=hover_text[group.index], hoverinfo='text'\n            ))\n            fig.add_trace(go.Scatter(\n                x=group[x_col], y=group['cum_upper'], name=f'{name}_upper',\n                fill=None, mode='lines', line=dict(width=0), showlegend=False\n            ))\n            fig.add_trace(go.Scatter(\n                x=group[x_col], y=group['cum_lower'], name=f'{name}_lower',\n                fill='tonexty', mode='lines', line=dict(width=0), showlegend=False,\n                hoverinfo='none'\n            ))\n\n        return fig.update_layout(\n            **self.theme,\n            title=f'Cumulative Coverage of {x_col} within {denominator_col}',\n            xaxis=dict(title=x_col, categoryorder='array', categoryarray=x_order),\n            yaxis=dict(title='Cumulative Proportion (Coverage)', tickformat='.2f'),\n        ).update_xaxes(tickangle=45)\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.CoveragePlotter.__init__","title":"<code>__init__(x_order=None, max_x=15, theme=_THEME)</code>","text":"<p>Initializes the CoveragePlotter.</p> <p>Parameters:</p> Name Type Description Default <code>x_order</code> <code>List[str]</code> <p>The order of categories on the x-axis. Defaults to None, which orders by descending total count.</p> <code>None</code> <code>max_x</code> <code>int</code> <p>The maximum number of x-axis categories to display. Defaults to 15.</p> <code>15</code> <code>theme</code> <code>dict</code> <p>A dictionary of Plotly layout settings. Defaults to _THEME.</p> <code>_THEME</code> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>def __init__(self, x_order: List[str] = None, max_x: int = 15, theme: dict = _THEME):\n    \"\"\"Initializes the CoveragePlotter.\n\n    Args:\n        x_order (List[str], optional): The order of categories on the x-axis.\n            Defaults to None, which orders by descending total count.\n        max_x (int, optional): The maximum number of x-axis categories to display.\n            Defaults to 15.\n        theme (dict, optional): A dictionary of Plotly layout settings. Defaults to _THEME.\n    \"\"\"\n    self.x_order = x_order\n    self.max_x = max_x\n    self.theme = theme\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.CoveragePlotter.plot","title":"<code>plot(result)</code>","text":"<p>Generates a cumulative coverage plot from a PrevalenceResult.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>PrevalenceResult</code> <p>The prevalence result, which must be stratified by at least two columns and have a denominator.</p> required <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: A Plotly figure object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the result is not stratified by at least two columns or does not have a denominator.</p> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>def plot(self, result: PrevalenceResult) -&gt; go.Figure:\n    \"\"\"Generates a cumulative coverage plot from a PrevalenceResult.\n\n    Args:\n        result (PrevalenceResult): The prevalence result, which must be stratified\n            by at least two columns and have a denominator.\n\n    Returns:\n        go.Figure: A Plotly figure object.\n\n    Raises:\n        ValueError: If the result is not stratified by at least two columns\n            or does not have a denominator.\n    \"\"\"\n    if not result.denominator or len(result.stratified_by) &lt; 2:\n        raise ValueError(\"CoveragePlotter requires results stratified by at least two columns with a denominator.\")\n\n    data = result.data\n    denominator_col = result.denominator\n    x_col = next(c for c in result.stratified_by if c != denominator_col)\n\n    # Determine X-axis order\n    if self.x_order:\n        x_order = self.x_order\n    else:\n        # Default to ordering by total count across all denominators\n        x_order = data.groupby(x_col)['count.raw'].sum().sort_values(ascending=False).index.tolist()\n\n    if self.max_x and len(x_order) &gt; self.max_x:\n        x_order = x_order[:self.max_x]\n\n    # Prepare data for plotting by creating all combinations\n    plot_data = (\n        data.set_index([denominator_col, x_col])\n        .reindex(\n            pd.MultiIndex.from_product([data[denominator_col].unique(), x_order], names=[denominator_col, x_col]))\n        .fillna(0)\n        .reset_index()\n    )\n\n    # Set the custom sort order for the x-axis column and then sort\n    plot_data[x_col] = pd.Categorical(plot_data[x_col], categories=x_order, ordered=True)\n    plot_data = plot_data.sort_values(by=[denominator_col, x_col])\n\n    # Calculate cumulative values within each denominator group\n    grouped = plot_data.groupby(denominator_col, sort=False)\n    plot_data['cum_prop'] = grouped['prop.raw'].cumsum()\n    plot_data['se_squared'] = plot_data['se.raw'] ** 2\n    # The error of a sum of proportions is complex. We approximate the\n    # cumulative error by summing the individual standard errors in quadrature.\n    plot_data['cum_se'] = np.sqrt(grouped['se_squared'].cumsum())\n\n    z = norm.ppf(1 - (0.05 / 2))\n    plot_data['cum_lower'] = (plot_data['cum_prop'] - z * plot_data['cum_se']).clip(0, 1)\n    plot_data['cum_upper'] = (plot_data['cum_prop'] + z * plot_data['cum_se']).clip(0, 1)\n\n    # Create hover text\n    hover_text = (\n            f\"&lt;b&gt;{x_col}&lt;/b&gt;: \" + plot_data[x_col].astype(str) +\n            f\"&lt;br&gt;&lt;b&gt;{denominator_col}&lt;/b&gt;: \" + plot_data[denominator_col].astype(str) +\n            \"&lt;br&gt;Individual Prop: \" + plot_data['prop.raw'].map('{:.3f}'.format) +\n            \"&lt;br&gt;Cumulative Prop: \" + plot_data['cum_prop'].map('{:.3f}'.format)\n    )\n\n    fig = go.Figure()\n    for name, group in plot_data.groupby(denominator_col):\n        fig.add_trace(go.Scatter(\n            x=group[x_col], y=group['cum_prop'], name=name,\n            mode='lines+markers', text=hover_text[group.index], hoverinfo='text'\n        ))\n        fig.add_trace(go.Scatter(\n            x=group[x_col], y=group['cum_upper'], name=f'{name}_upper',\n            fill=None, mode='lines', line=dict(width=0), showlegend=False\n        ))\n        fig.add_trace(go.Scatter(\n            x=group[x_col], y=group['cum_lower'], name=f'{name}_lower',\n            fill='tonexty', mode='lines', line=dict(width=0), showlegend=False,\n            hoverinfo='none'\n        ))\n\n    return fig.update_layout(\n        **self.theme,\n        title=f'Cumulative Coverage of {x_col} within {denominator_col}',\n        xaxis=dict(title=x_col, categoryorder='array', categoryarray=x_order),\n        yaxis=dict(title='Cumulative Proportion (Coverage)', tickformat='.2f'),\n    ).update_xaxes(tickangle=45)\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.MapPlotter","title":"<code>MapPlotter</code>","text":"<p>Creates an interactive choropleth map to visualize geographical coverage.</p> <p>This plotter takes a prevalence result, summarizes the cumulative coverage for a selected list of antigens within each geographical area, and displays it on a world map.</p> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>class MapPlotter:\n    \"\"\"\n    Creates an interactive choropleth map to visualize geographical coverage.\n\n    This plotter takes a prevalence result, summarizes the cumulative coverage\n    for a selected list of antigens within each geographical area, and\n    displays it on a world map.\n    \"\"\"\n\n    def __init__(self, low_col: str = _LOW_COLOUR, high_col: str = _HIGH_COLOUR):\n        \"\"\"Initializes the MapPlotter.\n\n        Args:\n            low_col (str, optional): The color for low coverage areas on the map.\n                Defaults to _LOW_COLOUR.\n            high_col (str, optional): The color for high coverage areas on the map.\n                Defaults to _HIGH_COLOUR.\n        \"\"\"\n        # shape_file: Path = _NE_COUNTRIES\n        # self.world: geopandas.GeoDataFrame = geopandas.read_file(shape_file)\n        self.world: geopandas.GeoDataFrame = _WORLD\n        self.low_col = low_col\n        self.high_col = high_col\n\n    def plot(self, result: PrevalenceResult, world_col: str = 'name') -&gt; go.Figure:\n        \"\"\"Generates a choropleth map from a PrevalenceResult.\n\n        The plot visualizes geographical data by merging prevalence results with a\n        world map shapefile.\n\n        Args:\n            result (PrevalenceResult): The prevalence result containing geographical data.\n            world_col (str, optional): The column name in the world shapefile to join on.\n                Defaults to 'name'.\n\n        Returns:\n            go.Figure: A Plotly figure object representing the map.\n\n        Raises:\n            ValueError: If `world_col` is not in the world dataframe, or if the\n                `PrevalenceResult` is not in a format that can be mapped.\n        \"\"\"\n        data = result.data\n        if world_col not in self.world.columns:\n            raise ValueError(f'{world_col} not in world dataframe')\n\n        # Define color interpolation logic here for the callback\n        low_rgb = tuple(int(self.low_col.lstrip('#')[i:i + 2], 16) for i in (0, 2, 4))\n        high_rgb = tuple(int(self.high_col.lstrip('#')[i:i + 2], 16) for i in (0, 2, 4))\n\n        def color_map(coverage: float) -&gt; str:\n            rgb = [int(low + (high - low) * coverage) for low, high in zip(low_rgb, high_rgb)]\n            return f'rgb({rgb[0]},{rgb[1]},{rgb[2]})'\n\n        # Scenario 1: Data is already aggregated by a single geo-stratum\n        if not result.denominator and len(result.stratified_by) == 1:\n            geo_col = result.stratified_by[0]\n            map_data = data.rename(columns={'prop.raw': 'Coverage', 'count.raw': 'Infections'})\n        # Scenario 2: Data is stratified by geo (denominator) and something else\n        elif result.denominator and len(result.stratified_by) &gt; 1:\n            geo_col = result.denominator\n            map_data = (\n                data.groupby(geo_col)\n                .agg(\n                    Infections=('count.raw', 'sum'),\n                    Coverage=('prop.raw', 'sum')\n                )\n                .assign(Coverage=lambda df: df['Coverage'].clip(upper=1.0))\n                .reset_index()\n            )\n        else:\n            raise ValueError(\n                \"MapPlotter requires a PrevalenceResult with either a single geographical stratum \"\n                \"or multiple strata with the geographical column as the denominator.\"\n            )\n        # Merge summarized data with geospatial data\n        # Note: This assumes the geo_col in your data ('Country') matches the 'name' column in the world dataset.\n        # You may need to adjust this mapping if your names differ (e.g., 'United States' vs 'United States of America').\n        merged_data = self.world.merge(map_data, how=\"inner\", left_on=world_col, right_on=geo_col)\n        merged_data['Coverage'] = merged_data['Coverage'].fillna(0)  # Fill non-matching countries with 0\n\n        fig = go.Figure(go.Choroplethmapbox(\n            geojson=merged_data.__geo_interface__,\n            locations=merged_data.index,  # Use the GeoDataFrame index\n            z=merged_data['Coverage'],\n            colorscale=[self.low_col, self.high_col],\n            zmin=0,\n            zmax=1,\n            marker_opacity=0.6,\n            marker_line_width=0.5,\n            colorbar_title='Coverage',\n            customdata=merged_data[['name', 'Infections', 'Coverage']],\n            hovertemplate=(\n                \"&lt;b&gt;%{customdata[0]}&lt;/b&gt;&lt;br&gt;\"\n                \"Infections: %{customdata[1]}&lt;br&gt;\"\n                \"Coverage: %{customdata[2]:.3f}&lt;extra&gt;&lt;/extra&gt;\"\n            )\n        ))\n        fig.update_layout(\n            mapbox_style=\"carto-positron\",\n            mapbox_zoom=1,\n            mapbox_center={\"lat\": 25, \"lon\": 0},\n            margin={\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0}\n        )\n        return fig\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.MapPlotter.__init__","title":"<code>__init__(low_col=_LOW_COLOUR, high_col=_HIGH_COLOUR)</code>","text":"<p>Initializes the MapPlotter.</p> <p>Parameters:</p> Name Type Description Default <code>low_col</code> <code>str</code> <p>The color for low coverage areas on the map. Defaults to _LOW_COLOUR.</p> <code>_LOW_COLOUR</code> <code>high_col</code> <code>str</code> <p>The color for high coverage areas on the map. Defaults to _HIGH_COLOUR.</p> <code>_HIGH_COLOUR</code> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>def __init__(self, low_col: str = _LOW_COLOUR, high_col: str = _HIGH_COLOUR):\n    \"\"\"Initializes the MapPlotter.\n\n    Args:\n        low_col (str, optional): The color for low coverage areas on the map.\n            Defaults to _LOW_COLOUR.\n        high_col (str, optional): The color for high coverage areas on the map.\n            Defaults to _HIGH_COLOUR.\n    \"\"\"\n    # shape_file: Path = _NE_COUNTRIES\n    # self.world: geopandas.GeoDataFrame = geopandas.read_file(shape_file)\n    self.world: geopandas.GeoDataFrame = _WORLD\n    self.low_col = low_col\n    self.high_col = high_col\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.MapPlotter.plot","title":"<code>plot(result, world_col='name')</code>","text":"<p>Generates a choropleth map from a PrevalenceResult.</p> <p>The plot visualizes geographical data by merging prevalence results with a world map shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>PrevalenceResult</code> <p>The prevalence result containing geographical data.</p> required <code>world_col</code> <code>str</code> <p>The column name in the world shapefile to join on. Defaults to 'name'.</p> <code>'name'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: A Plotly figure object representing the map.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>world_col</code> is not in the world dataframe, or if the <code>PrevalenceResult</code> is not in a format that can be mapped.</p> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>def plot(self, result: PrevalenceResult, world_col: str = 'name') -&gt; go.Figure:\n    \"\"\"Generates a choropleth map from a PrevalenceResult.\n\n    The plot visualizes geographical data by merging prevalence results with a\n    world map shapefile.\n\n    Args:\n        result (PrevalenceResult): The prevalence result containing geographical data.\n        world_col (str, optional): The column name in the world shapefile to join on.\n            Defaults to 'name'.\n\n    Returns:\n        go.Figure: A Plotly figure object representing the map.\n\n    Raises:\n        ValueError: If `world_col` is not in the world dataframe, or if the\n            `PrevalenceResult` is not in a format that can be mapped.\n    \"\"\"\n    data = result.data\n    if world_col not in self.world.columns:\n        raise ValueError(f'{world_col} not in world dataframe')\n\n    # Define color interpolation logic here for the callback\n    low_rgb = tuple(int(self.low_col.lstrip('#')[i:i + 2], 16) for i in (0, 2, 4))\n    high_rgb = tuple(int(self.high_col.lstrip('#')[i:i + 2], 16) for i in (0, 2, 4))\n\n    def color_map(coverage: float) -&gt; str:\n        rgb = [int(low + (high - low) * coverage) for low, high in zip(low_rgb, high_rgb)]\n        return f'rgb({rgb[0]},{rgb[1]},{rgb[2]})'\n\n    # Scenario 1: Data is already aggregated by a single geo-stratum\n    if not result.denominator and len(result.stratified_by) == 1:\n        geo_col = result.stratified_by[0]\n        map_data = data.rename(columns={'prop.raw': 'Coverage', 'count.raw': 'Infections'})\n    # Scenario 2: Data is stratified by geo (denominator) and something else\n    elif result.denominator and len(result.stratified_by) &gt; 1:\n        geo_col = result.denominator\n        map_data = (\n            data.groupby(geo_col)\n            .agg(\n                Infections=('count.raw', 'sum'),\n                Coverage=('prop.raw', 'sum')\n            )\n            .assign(Coverage=lambda df: df['Coverage'].clip(upper=1.0))\n            .reset_index()\n        )\n    else:\n        raise ValueError(\n            \"MapPlotter requires a PrevalenceResult with either a single geographical stratum \"\n            \"or multiple strata with the geographical column as the denominator.\"\n        )\n    # Merge summarized data with geospatial data\n    # Note: This assumes the geo_col in your data ('Country') matches the 'name' column in the world dataset.\n    # You may need to adjust this mapping if your names differ (e.g., 'United States' vs 'United States of America').\n    merged_data = self.world.merge(map_data, how=\"inner\", left_on=world_col, right_on=geo_col)\n    merged_data['Coverage'] = merged_data['Coverage'].fillna(0)  # Fill non-matching countries with 0\n\n    fig = go.Figure(go.Choroplethmapbox(\n        geojson=merged_data.__geo_interface__,\n        locations=merged_data.index,  # Use the GeoDataFrame index\n        z=merged_data['Coverage'],\n        colorscale=[self.low_col, self.high_col],\n        zmin=0,\n        zmax=1,\n        marker_opacity=0.6,\n        marker_line_width=0.5,\n        colorbar_title='Coverage',\n        customdata=merged_data[['name', 'Infections', 'Coverage']],\n        hovertemplate=(\n            \"&lt;b&gt;%{customdata[0]}&lt;/b&gt;&lt;br&gt;\"\n            \"Infections: %{customdata[1]}&lt;br&gt;\"\n            \"Coverage: %{customdata[2]:.3f}&lt;extra&gt;&lt;/extra&gt;\"\n        )\n    ))\n    fig.update_layout(\n        mapbox_style=\"carto-positron\",\n        mapbox_zoom=1,\n        mapbox_center={\"lat\": 25, \"lon\": 0},\n        margin={\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0}\n    )\n    return fig\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.PrevalencePlotter","title":"<code>PrevalencePlotter</code>","text":"<p>Creates an interactive bar plot for <code>PrevalenceResult</code> objects.</p> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>class PrevalencePlotter:\n    \"\"\"Creates an interactive bar plot for `PrevalenceResult` objects.\"\"\"\n    def __init__(self, y_order: list[str] | pd.Series = None, fill_by: Literal['prop', 'rank', 'count'] = 'count',\n                 low_col: str = _LOW_COLOUR, high_col: str = _HIGH_COLOUR, theme: dict = _THEME):\n        \"\"\"Initializes the PrevalencePlotter.\n\n        Args:\n            y_order (list[str] | pd.Series, optional): The order of categories on the y-axis.\n                Defaults to None, which uses the order from the data.\n            fill_by (Literal['prop', 'rank', 'count'], optional): The variable to use for color-filling the bars.\n                Defaults to 'count'.\n            low_col (str, optional): The color for the low end of the scale. Defaults to _LOW_COLOUR.\n            high_col (str, optional): The color for the high end of the scale. Defaults to _HIGH_COLOUR.\n            theme (dict, optional): A dictionary of Plotly layout settings. Defaults to _THEME.\n        \"\"\"\n        self.y_order = y_order\n        self.fill_by = fill_by\n        self.low_col = low_col\n        self.high_col = high_col\n        self.theme = theme\n\n    def _create_go(self, data: pd.DataFrame, y_col_name: str, col_type: str) -&gt; go.Bar:\n        \"\"\"Creates a single bar trace for a subplot.\"\"\"\n        prop_col = f'prop.{col_type}'\n        upper_col = f'upper.{col_type}'\n        lower_col = f'lower.{col_type}'\n        fill_col = f'{self.fill_by}.{col_type}'\n\n        # Vectorized hover text generation (highly efficient)\n        hover_text = (\n                f\"&lt;b&gt;{y_col_name}&lt;/b&gt;: \" + data[y_col_name].astype(str) +\n                \"&lt;br&gt;&lt;b&gt;Proportion&lt;/b&gt;: \" + data[prop_col].map('{:.3f}'.format) +\n                f\"&lt;br&gt;&lt;b&gt;{self.fill_by.capitalize()}&lt;/b&gt;: \" + data[fill_col].astype(str) +\n                \"&lt;br&gt;&lt;b&gt;Denominator&lt;/b&gt;: \" + data[f'denominator.{col_type}'].astype(str)\n        )\n        return go.Bar(\n            y=data[y_col_name],\n            x=data[prop_col],\n            orientation='h',\n            name=prop_col,\n            hoverinfo='text',\n            hovertext=hover_text,\n            marker=go.bar.Marker(color=data[fill_col], colorscale=[self.low_col, self.high_col]),\n            error_x=go.bar.ErrorX(type='data', symmetric=False, array=data[upper_col], arrayminus=data[lower_col])\n        )\n\n    def plot(self, result: PrevalenceResult) -&gt; go.Figure:\n        \"\"\"Generates a bar plot from a PrevalenceResult.\n\n        The plot will show raw prevalence and adjusted prevalence if available.\n\n        Args:\n            result (PrevalenceResult): The prevalence calculation result to plot.\n\n        Returns:\n            go.Figure: A Plotly figure object.\n        \"\"\"\n        data = result.data\n        y_col_name = result.stratified_by[-1]  # Plot by the finest stratification level\n        # Set a sensible default sort order if none is provided\n        y_order = self.y_order or data[y_col_name].unique().tolist()\n        # Filter data to only include categories in y_order\n        data = data[data[y_col_name].isin(y_order)]\n        col_types = ['raw', 'adj'] if result.adjusted_for else ['raw']\n\n        fig = make_subplots(\n            rows=1, cols=len(col_types), shared_yaxes=True,\n            subplot_titles=[f'{i.capitalize()} Prevalence' for i in col_types],\n            horizontal_spacing=0.01\n        )\n\n        for col, col_type in enumerate(col_types, start=1):  # Add subplots\n            fig.add_trace(self._create_go(data, y_col_name, col_type), row=1, col=col)\n\n        fig.update_layout(\n            **self.theme,\n            showlegend=False,\n            barmode='relative',\n            yaxis=dict(title=y_col_name, categoryorder='array', categoryarray=y_order, autorange=\"reversed\"),\n            xaxis1=dict(title='Raw Proportion', autorange=\"reversed\", tickformat='.1f'),\n        )\n        if len(col_types) &gt; 1:\n            return fig.update_layout(xaxis2=dict(title='Adjusted Proportion', tickformat='.1f'))\n        return fig\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.PrevalencePlotter.__init__","title":"<code>__init__(y_order=None, fill_by='count', low_col=_LOW_COLOUR, high_col=_HIGH_COLOUR, theme=_THEME)</code>","text":"<p>Initializes the PrevalencePlotter.</p> <p>Parameters:</p> Name Type Description Default <code>y_order</code> <code>list[str] | Series</code> <p>The order of categories on the y-axis. Defaults to None, which uses the order from the data.</p> <code>None</code> <code>fill_by</code> <code>Literal['prop', 'rank', 'count']</code> <p>The variable to use for color-filling the bars. Defaults to 'count'.</p> <code>'count'</code> <code>low_col</code> <code>str</code> <p>The color for the low end of the scale. Defaults to _LOW_COLOUR.</p> <code>_LOW_COLOUR</code> <code>high_col</code> <code>str</code> <p>The color for the high end of the scale. Defaults to _HIGH_COLOUR.</p> <code>_HIGH_COLOUR</code> <code>theme</code> <code>dict</code> <p>A dictionary of Plotly layout settings. Defaults to _THEME.</p> <code>_THEME</code> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>def __init__(self, y_order: list[str] | pd.Series = None, fill_by: Literal['prop', 'rank', 'count'] = 'count',\n             low_col: str = _LOW_COLOUR, high_col: str = _HIGH_COLOUR, theme: dict = _THEME):\n    \"\"\"Initializes the PrevalencePlotter.\n\n    Args:\n        y_order (list[str] | pd.Series, optional): The order of categories on the y-axis.\n            Defaults to None, which uses the order from the data.\n        fill_by (Literal['prop', 'rank', 'count'], optional): The variable to use for color-filling the bars.\n            Defaults to 'count'.\n        low_col (str, optional): The color for the low end of the scale. Defaults to _LOW_COLOUR.\n        high_col (str, optional): The color for the high end of the scale. Defaults to _HIGH_COLOUR.\n        theme (dict, optional): A dictionary of Plotly layout settings. Defaults to _THEME.\n    \"\"\"\n    self.y_order = y_order\n    self.fill_by = fill_by\n    self.low_col = low_col\n    self.high_col = high_col\n    self.theme = theme\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.PrevalencePlotter.plot","title":"<code>plot(result)</code>","text":"<p>Generates a bar plot from a PrevalenceResult.</p> <p>The plot will show raw prevalence and adjusted prevalence if available.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>PrevalenceResult</code> <p>The prevalence calculation result to plot.</p> required <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: A Plotly figure object.</p> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>def plot(self, result: PrevalenceResult) -&gt; go.Figure:\n    \"\"\"Generates a bar plot from a PrevalenceResult.\n\n    The plot will show raw prevalence and adjusted prevalence if available.\n\n    Args:\n        result (PrevalenceResult): The prevalence calculation result to plot.\n\n    Returns:\n        go.Figure: A Plotly figure object.\n    \"\"\"\n    data = result.data\n    y_col_name = result.stratified_by[-1]  # Plot by the finest stratification level\n    # Set a sensible default sort order if none is provided\n    y_order = self.y_order or data[y_col_name].unique().tolist()\n    # Filter data to only include categories in y_order\n    data = data[data[y_col_name].isin(y_order)]\n    col_types = ['raw', 'adj'] if result.adjusted_for else ['raw']\n\n    fig = make_subplots(\n        rows=1, cols=len(col_types), shared_yaxes=True,\n        subplot_titles=[f'{i.capitalize()} Prevalence' for i in col_types],\n        horizontal_spacing=0.01\n    )\n\n    for col, col_type in enumerate(col_types, start=1):  # Add subplots\n        fig.add_trace(self._create_go(data, y_col_name, col_type), row=1, col=col)\n\n    fig.update_layout(\n        **self.theme,\n        showlegend=False,\n        barmode='relative',\n        yaxis=dict(title=y_col_name, categoryorder='array', categoryarray=y_order, autorange=\"reversed\"),\n        xaxis1=dict(title='Raw Proportion', autorange=\"reversed\", tickformat='.1f'),\n    )\n    if len(col_types) &gt; 1:\n        return fig.update_layout(xaxis2=dict(title='Adjusted Proportion', tickformat='.1f'))\n    return fig\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.StrataPlotter","title":"<code>StrataPlotter</code>","text":"<p>Creates an interactive heatmap plot for looking at prevalence of one stratum within another.</p> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>class StrataPlotter:\n    \"\"\"\n    Creates an interactive heatmap plot for looking at prevalence of one stratum within another.\n    \"\"\"\n\n    def __init__(\n            self, y_order: list[str] | pd.Series = None,\n            # fill_by: Literal['prop.raw', 'rank.raw', 'count.raw', 'prop.adj', 'rank.adj', 'count.adj'] = 'prop.raw',\n            max_x: int = _MAX_X, low_col: str = _LOW_COLOUR, high_col: str = _HIGH_COLOUR, theme: dict = _THEME\n    ):\n        \"\"\"Initializes the StrataPlotter.\n\n        Args:\n            y_order (list[str] | pd.Series, optional): The order of categories on the y-axis.\n                Defaults to None, which uses the order from the data.\n            max_x (int, optional): The maximum number of categories to show on the x-axis\n                before grouping the rest into \"Other\". Defaults to _MAX_X.\n            low_col (str, optional): The color for the low end of the heatmap scale.\n                Defaults to _LOW_COLOUR.\n            high_col (str, optional): The color for the high end of the heatmap scale.\n                Defaults to _HIGH_COLOUR.\n            theme (dict, optional): A dictionary of Plotly layout settings. Defaults to _THEME.\n        \"\"\"\n        self.y_order = y_order\n        # self.fill_by = fill_by\n        self.max_x = max_x\n        self.low_col = low_col\n        self.high_col = high_col\n        self.theme = theme\n\n    def plot(self, result: PrevalenceResult) -&gt; go.Figure:\n        \"\"\"Generates a heatmap from a PrevalenceResult stratified by two columns.\n\n        Args:\n            result (PrevalenceResult): The prevalence result, which must be stratified\n                by exactly two columns.\n\n        Returns:\n            go.Figure: A Plotly figure object representing the heatmap.\n\n        Raises:\n            ValueError: If the result is not stratified by exactly two columns.\n        \"\"\"\n        if not result.denominator or len(result.stratified_by) != 2:\n            raise ValueError(\"StrataPlotter requires results stratified by exactly two columns with a denominator.\")\n\n        data = result.data\n        # The first stratified column is always Y, the second is always X.\n        y_col_name, x_col_name = result.stratified_by[0], result.stratified_by[1]\n        if y_col_name == result.denominator:  # denominator has not been swapped\n            numerator = x_col_name\n            denominator_swapped = False\n        else:\n            numerator = y_col_name\n            denominator_swapped = True\n        # Determine Y-axis order and filter data\n        y_order = self.y_order or data[y_col_name].unique().tolist()\n        data = data[data[y_col_name].isin(y_order)]\n\n        # Determine X-axis order and group less frequent categories into \"Other\"\n        x_order = data[x_col_name].value_counts().index.tolist()\n        if len(x_order) &gt; self.max_x:\n            top_x = x_order[:self.max_x]\n            if not denominator_swapped:\n                other_name = f\"Other ({len(x_order) - self.max_x})\"\n                # Use the more efficient, vectorized .where() method instead of .apply()\n                data[x_col_name] = data[x_col_name].where(data[x_col_name].isin(top_x), other_name)\n                x_order = top_x + [other_name]\n\n        # Summarize data after potential \"Other\" grouping.\n        plot_data = data.groupby([y_col_name, x_col_name])['prop.raw'].sum().reset_index()\n        # Create hover text\n        hover_text = (\n                f\"&lt;b&gt;{y_col_name}&lt;/b&gt;: \" + plot_data[y_col_name].astype(str) +\n                f\"&lt;br&gt;&lt;b&gt;{x_col_name}&lt;/b&gt;: \" + plot_data[x_col_name].astype(str) +\n                f\"&lt;br&gt;&lt;b&gt;Prop&lt;/b&gt;: \" +\n                plot_data['prop.raw'].map('{:.3f}'.format)\n        )\n        # Create the heatmap trace\n        return go.Figure(\n            go.Heatmap(\n                x=plot_data[x_col_name],\n                y=plot_data[y_col_name],\n                z=plot_data['prop.raw'],\n                text=hover_text,\n                hoverinfo='text',\n                colorscale=[self.low_col, self.high_col],\n                colorbar={'title': 'Proportion'},\n            )\n        ).update_layout(\n            **self.theme,\n            title=f'Proportion of&lt;br&gt;{numerator} within {result.denominator}',\n            xaxis=dict(title=x_col_name, categoryorder='array', categoryarray=x_order),\n            yaxis=dict(title=y_col_name, categoryorder='array', categoryarray=y_order, autorange=\"reversed\"),\n            # Set hover label background to match tile color\n            hoverlabel=dict(\n                bgcolor=\"rgba(0,0,0,0)\",  # Make the hover box background transparent\n                font=dict(color=\"white\")  # Set font color to white for visibility\n            )\n        ).update_xaxes(tickangle=45)\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.StrataPlotter.__init__","title":"<code>__init__(y_order=None, max_x=_MAX_X, low_col=_LOW_COLOUR, high_col=_HIGH_COLOUR, theme=_THEME)</code>","text":"<p>Initializes the StrataPlotter.</p> <p>Parameters:</p> Name Type Description Default <code>y_order</code> <code>list[str] | Series</code> <p>The order of categories on the y-axis. Defaults to None, which uses the order from the data.</p> <code>None</code> <code>max_x</code> <code>int</code> <p>The maximum number of categories to show on the x-axis before grouping the rest into \"Other\". Defaults to _MAX_X.</p> <code>_MAX_X</code> <code>low_col</code> <code>str</code> <p>The color for the low end of the heatmap scale. Defaults to _LOW_COLOUR.</p> <code>_LOW_COLOUR</code> <code>high_col</code> <code>str</code> <p>The color for the high end of the heatmap scale. Defaults to _HIGH_COLOUR.</p> <code>_HIGH_COLOUR</code> <code>theme</code> <code>dict</code> <p>A dictionary of Plotly layout settings. Defaults to _THEME.</p> <code>_THEME</code> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>def __init__(\n        self, y_order: list[str] | pd.Series = None,\n        # fill_by: Literal['prop.raw', 'rank.raw', 'count.raw', 'prop.adj', 'rank.adj', 'count.adj'] = 'prop.raw',\n        max_x: int = _MAX_X, low_col: str = _LOW_COLOUR, high_col: str = _HIGH_COLOUR, theme: dict = _THEME\n):\n    \"\"\"Initializes the StrataPlotter.\n\n    Args:\n        y_order (list[str] | pd.Series, optional): The order of categories on the y-axis.\n            Defaults to None, which uses the order from the data.\n        max_x (int, optional): The maximum number of categories to show on the x-axis\n            before grouping the rest into \"Other\". Defaults to _MAX_X.\n        low_col (str, optional): The color for the low end of the heatmap scale.\n            Defaults to _LOW_COLOUR.\n        high_col (str, optional): The color for the high end of the heatmap scale.\n            Defaults to _HIGH_COLOUR.\n        theme (dict, optional): A dictionary of Plotly layout settings. Defaults to _THEME.\n    \"\"\"\n    self.y_order = y_order\n    # self.fill_by = fill_by\n    self.max_x = max_x\n    self.low_col = low_col\n    self.high_col = high_col\n    self.theme = theme\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.StrataPlotter.plot","title":"<code>plot(result)</code>","text":"<p>Generates a heatmap from a PrevalenceResult stratified by two columns.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>PrevalenceResult</code> <p>The prevalence result, which must be stratified by exactly two columns.</p> required <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: A Plotly figure object representing the heatmap.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the result is not stratified by exactly two columns.</p> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>def plot(self, result: PrevalenceResult) -&gt; go.Figure:\n    \"\"\"Generates a heatmap from a PrevalenceResult stratified by two columns.\n\n    Args:\n        result (PrevalenceResult): The prevalence result, which must be stratified\n            by exactly two columns.\n\n    Returns:\n        go.Figure: A Plotly figure object representing the heatmap.\n\n    Raises:\n        ValueError: If the result is not stratified by exactly two columns.\n    \"\"\"\n    if not result.denominator or len(result.stratified_by) != 2:\n        raise ValueError(\"StrataPlotter requires results stratified by exactly two columns with a denominator.\")\n\n    data = result.data\n    # The first stratified column is always Y, the second is always X.\n    y_col_name, x_col_name = result.stratified_by[0], result.stratified_by[1]\n    if y_col_name == result.denominator:  # denominator has not been swapped\n        numerator = x_col_name\n        denominator_swapped = False\n    else:\n        numerator = y_col_name\n        denominator_swapped = True\n    # Determine Y-axis order and filter data\n    y_order = self.y_order or data[y_col_name].unique().tolist()\n    data = data[data[y_col_name].isin(y_order)]\n\n    # Determine X-axis order and group less frequent categories into \"Other\"\n    x_order = data[x_col_name].value_counts().index.tolist()\n    if len(x_order) &gt; self.max_x:\n        top_x = x_order[:self.max_x]\n        if not denominator_swapped:\n            other_name = f\"Other ({len(x_order) - self.max_x})\"\n            # Use the more efficient, vectorized .where() method instead of .apply()\n            data[x_col_name] = data[x_col_name].where(data[x_col_name].isin(top_x), other_name)\n            x_order = top_x + [other_name]\n\n    # Summarize data after potential \"Other\" grouping.\n    plot_data = data.groupby([y_col_name, x_col_name])['prop.raw'].sum().reset_index()\n    # Create hover text\n    hover_text = (\n            f\"&lt;b&gt;{y_col_name}&lt;/b&gt;: \" + plot_data[y_col_name].astype(str) +\n            f\"&lt;br&gt;&lt;b&gt;{x_col_name}&lt;/b&gt;: \" + plot_data[x_col_name].astype(str) +\n            f\"&lt;br&gt;&lt;b&gt;Prop&lt;/b&gt;: \" +\n            plot_data['prop.raw'].map('{:.3f}'.format)\n    )\n    # Create the heatmap trace\n    return go.Figure(\n        go.Heatmap(\n            x=plot_data[x_col_name],\n            y=plot_data[y_col_name],\n            z=plot_data['prop.raw'],\n            text=hover_text,\n            hoverinfo='text',\n            colorscale=[self.low_col, self.high_col],\n            colorbar={'title': 'Proportion'},\n        )\n    ).update_layout(\n        **self.theme,\n        title=f'Proportion of&lt;br&gt;{numerator} within {result.denominator}',\n        xaxis=dict(title=x_col_name, categoryorder='array', categoryarray=x_order),\n        yaxis=dict(title=y_col_name, categoryorder='array', categoryarray=y_order, autorange=\"reversed\"),\n        # Set hover label background to match tile color\n        hoverlabel=dict(\n            bgcolor=\"rgba(0,0,0,0)\",  # Make the hover box background transparent\n            font=dict(color=\"white\")  # Set font color to white for visibility\n        )\n    ).update_xaxes(tickangle=45)\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.SummaryBarPlotter","title":"<code>SummaryBarPlotter</code>","text":"<p>Creates a horizontal bar plot to summarize a numeric variable against a categorical variable from a PrevalenceResult.</p> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>class SummaryBarPlotter:\n    \"\"\"\n    Creates a horizontal bar plot to summarize a numeric variable against a\n    categorical variable from a PrevalenceResult.\n    \"\"\"\n\n    def __init__(self, fill_by: str, y_order: list[str] | pd.Series = None, fill_color: str = _FILL_COLOUR,\n                 theme: dict = _THEME):\n        \"\"\"Initializes the SummaryBarPlotter.\n\n        Args:\n            fill_by (str): The numeric variable to plot on the x-axis (e.g., a distinct count).\n            y_order (list[str] | pd.Series, optional): The order of categories on the y-axis.\n                Defaults to None, which uses the order from the data.\n            fill_color (str, optional): The color for the bars. Defaults to _FILL_COLOUR.\n            theme (dict, optional): A dictionary of Plotly layout settings. Defaults to _THEME.\n        \"\"\"\n        self.fill_by = fill_by\n        self.y_order = y_order\n        self.fill_color = fill_color\n        self.theme = theme\n\n    def plot(self, result: PrevalenceResult) -&gt; go.Figure:\n        \"\"\"Generates a summary bar plot from a PrevalenceResult.\n\n        Args:\n            result (PrevalenceResult): The prevalence calculation result to plot.\n\n        Returns:\n            go.Figure: A Plotly figure object.\n\n        Raises:\n            ValueError: If the `fill_by` variable is not found in the result data.\n        \"\"\"\n        data = result.data\n        y_col_name = result.stratified_by[0]\n        x_col_name = f\"# {self.fill_by}\"\n\n        # Set a sensible default sort order if none is provided, and filter data\n        y_order = self.y_order or data[y_col_name].unique().tolist()\n        data = data[data[y_col_name].isin(y_order)]\n        if self.fill_by not in result.n_distinct or x_col_name not in data.columns:\n            raise ValueError(f\"Variable '{x_col_name}' not found in the result data. \"\n                             f\"Ensure '{self.fill_by}' was in `n_distinct` during calculation.\")\n\n        hover_text = (\n                f\"&lt;b&gt;{y_col_name}&lt;/b&gt;: \" + data[y_col_name].astype(str) +\n                f\"&lt;br&gt;&lt;b&gt;{x_col_name}&lt;/b&gt;: \" + data[x_col_name].astype(str)\n        )\n\n        return go.Figure(go.Bar(\n            x=data[x_col_name],\n            y=data[y_col_name],\n            orientation='h',\n            text=hover_text,\n            hoverinfo='text',\n            marker=dict(color=self.fill_color, line=dict(color='black', width=0.5))\n        )).update_layout(\n            **self.theme,\n            showlegend=False,\n            xaxis_title=x_col_name,\n            yaxis=dict(title=y_col_name, categoryorder='array', categoryarray=y_order, autorange=\"reversed\"),\n            title=f'Distinct {x_col_name}&lt;br&gt;per {y_col_name}'\n        )\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.SummaryBarPlotter.__init__","title":"<code>__init__(fill_by, y_order=None, fill_color=_FILL_COLOUR, theme=_THEME)</code>","text":"<p>Initializes the SummaryBarPlotter.</p> <p>Parameters:</p> Name Type Description Default <code>fill_by</code> <code>str</code> <p>The numeric variable to plot on the x-axis (e.g., a distinct count).</p> required <code>y_order</code> <code>list[str] | Series</code> <p>The order of categories on the y-axis. Defaults to None, which uses the order from the data.</p> <code>None</code> <code>fill_color</code> <code>str</code> <p>The color for the bars. Defaults to _FILL_COLOUR.</p> <code>_FILL_COLOUR</code> <code>theme</code> <code>dict</code> <p>A dictionary of Plotly layout settings. Defaults to _THEME.</p> <code>_THEME</code> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>def __init__(self, fill_by: str, y_order: list[str] | pd.Series = None, fill_color: str = _FILL_COLOUR,\n             theme: dict = _THEME):\n    \"\"\"Initializes the SummaryBarPlotter.\n\n    Args:\n        fill_by (str): The numeric variable to plot on the x-axis (e.g., a distinct count).\n        y_order (list[str] | pd.Series, optional): The order of categories on the y-axis.\n            Defaults to None, which uses the order from the data.\n        fill_color (str, optional): The color for the bars. Defaults to _FILL_COLOUR.\n        theme (dict, optional): A dictionary of Plotly layout settings. Defaults to _THEME.\n    \"\"\"\n    self.fill_by = fill_by\n    self.y_order = y_order\n    self.fill_color = fill_color\n    self.theme = theme\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.SummaryBarPlotter.plot","title":"<code>plot(result)</code>","text":"<p>Generates a summary bar plot from a PrevalenceResult.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>PrevalenceResult</code> <p>The prevalence calculation result to plot.</p> required <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: A Plotly figure object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>fill_by</code> variable is not found in the result data.</p> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>def plot(self, result: PrevalenceResult) -&gt; go.Figure:\n    \"\"\"Generates a summary bar plot from a PrevalenceResult.\n\n    Args:\n        result (PrevalenceResult): The prevalence calculation result to plot.\n\n    Returns:\n        go.Figure: A Plotly figure object.\n\n    Raises:\n        ValueError: If the `fill_by` variable is not found in the result data.\n    \"\"\"\n    data = result.data\n    y_col_name = result.stratified_by[0]\n    x_col_name = f\"# {self.fill_by}\"\n\n    # Set a sensible default sort order if none is provided, and filter data\n    y_order = self.y_order or data[y_col_name].unique().tolist()\n    data = data[data[y_col_name].isin(y_order)]\n    if self.fill_by not in result.n_distinct or x_col_name not in data.columns:\n        raise ValueError(f\"Variable '{x_col_name}' not found in the result data. \"\n                         f\"Ensure '{self.fill_by}' was in `n_distinct` during calculation.\")\n\n    hover_text = (\n            f\"&lt;b&gt;{y_col_name}&lt;/b&gt;: \" + data[y_col_name].astype(str) +\n            f\"&lt;br&gt;&lt;b&gt;{x_col_name}&lt;/b&gt;: \" + data[x_col_name].astype(str)\n    )\n\n    return go.Figure(go.Bar(\n        x=data[x_col_name],\n        y=data[y_col_name],\n        orientation='h',\n        text=hover_text,\n        hoverinfo='text',\n        marker=dict(color=self.fill_color, line=dict(color='black', width=0.5))\n    )).update_layout(\n        **self.theme,\n        showlegend=False,\n        xaxis_title=x_col_name,\n        yaxis=dict(title=y_col_name, categoryorder='array', categoryarray=y_order, autorange=\"reversed\"),\n        title=f'Distinct {x_col_name}&lt;br&gt;per {y_col_name}'\n    )\n</code></pre>"},{"location":"reference/pathogenx/app/plotters/#pathogenx.app.plotters.merge_prevalence_figs","title":"<code>merge_prevalence_figs(prevalence, strata=None, summary_bar=None)</code>","text":"<p>Merges traces from up to three figures into a single figure.</p> Source code in <code>pathogenx/app/plotters.py</code> <pre><code>def merge_prevalence_figs(prevalence: go.Figure, strata: go.Figure = None, summary_bar: go.Figure = None) -&gt; go.Figure | None:\n    \"\"\"Merges traces from up to three figures into a single figure.\"\"\"\n    plots = [prevalence]\n    if strata:\n        plots.append(strata)\n    if summary_bar:\n        plots.append(summary_bar)\n\n    traces = [trace for p in plots for trace in p.data]\n    if not traces:\n        return None\n\n    num_prevalence_plots = len(prevalence.data)\n\n    column_widths = []\n    if num_prevalence_plots == 1:\n        column_widths.extend([0.4])\n    elif num_prevalence_plots == 2:\n        column_widths.extend([0.2, 0.2])\n\n    if strata:\n        column_widths.append(0.4)\n    if summary_bar:\n        column_widths.append(0.2)\n\n    # Subplot titles for prevalence are in annotations. For others, in title.\n    subplot_titles = []\n    for ann in prevalence.layout.annotations:\n        subplot_titles.append(ann.text)\n    if strata:\n        subplot_titles.append(strata.layout.title.text)\n    if summary_bar:\n        subplot_titles.append(summary_bar.layout.title.text)\n\n    fig = make_subplots(\n        rows=1,\n        cols=len(traces),\n        shared_yaxes=True,\n        column_widths=column_widths if len(column_widths) == len(traces) else None,\n        horizontal_spacing=0.01,\n        subplot_titles=subplot_titles\n    )\n\n    for n, trace in enumerate(traces, start=1):\n        fig.add_trace(trace, row=1, col=n)\n\n    fig.update_layout(yaxis=prevalence.layout.yaxis)\n\n    col_idx = 1\n    if num_prevalence_plots == 2:  # Raw + Adjusted\n        fig.update_xaxes(title=prevalence.layout.xaxis1.title, tickformat=prevalence.layout.xaxis1.tickformat,\n                         autorange=prevalence.layout.xaxis1.autorange, row=1, col=col_idx)\n        col_idx += 1\n        fig.update_xaxes(title=prevalence.layout.xaxis2.title, tickformat=prevalence.layout.xaxis2.tickformat,\n                         autorange=prevalence.layout.xaxis2.autorange, row=1, col=col_idx)\n        col_idx += 1\n    elif num_prevalence_plots == 1:  # Raw only\n        # The prevalence plotter has a bug where the title is on xaxis1 even for a single plot.\n        fig.update_xaxes(title=prevalence.layout.xaxis1.title, tickformat=prevalence.layout.xaxis1.tickformat,\n                         autorange=prevalence.layout.xaxis1.autorange, row=1, col=col_idx)\n        col_idx += 1\n\n    if strata:\n        fig.update_xaxes(patch=strata.layout.xaxis, row=1, col=col_idx)\n        col_idx += len(strata.data)\n\n    if summary_bar:\n        fig.update_xaxes(patch=summary_bar.layout.xaxis, row=1, col=col_idx)\n\n    return fig.update_layout(**_THEME, showlegend=False)\n</code></pre>"},{"location":"reference/pathogenx/app/server/","title":"pathogenx.app.server","text":"<p>Module for dealing with the web-app server logic</p>"},{"location":"reference/pathogenx/app/ui/","title":"pathogenx.app.ui","text":"<p>Module for dealing with the web-app user interface</p>"},{"location":"reference/pathogenx/app/utils/","title":"pathogenx.app.utils","text":"<p>Module containing generic app utility functions</p>"},{"location":"reference/pathogenx/app/utils/#pathogenx.app.utils.create_logo_link","title":"<code>create_logo_link(src, url, width, tooltip_text=None)</code>","text":"<p>Convenience function for creating a clickable image link that opens in a new tab.</p> Source code in <code>pathogenx/app/utils.py</code> <pre><code>def create_logo_link(src: str, url: str, width: str, tooltip_text: str | None = None):\n    \"\"\"\n    Convenience function for creating a clickable image link that opens in a new tab.\n    \"\"\"\n    link_tag = ui.a(ui.img(src=src, width=width, style=\"vertical-align: middle;\"),\n                    href=f'\"https://{url}', target=\"_blank\", id=f'{Path(src).stem}_logo')\n    if tooltip_text:\n        return ui.tooltip(link_tag, tooltip_text, placement='bottom')\n    return link_tag\n</code></pre>"},{"location":"reference/pathogenx/app/utils/#pathogenx.app.utils.dropdown_function","title":"<code>dropdown_function(id_, *args)</code>","text":"<p>Creates a dropdown menu with a gear icon.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>str</code> <p>The ID for the action button.</p> required <code>*args</code> <p>Arguments to be passed to the popover.</p> <code>()</code> <p>Returns:</p> Type Description <code>Tag</code> <p>A Shiny UI popover element.</p> Source code in <code>pathogenx/app/utils.py</code> <pre><code>def dropdown_function(id_, *args) -&gt; ui.Tag:\n    \"\"\"Creates a dropdown menu with a gear icon.\n\n    Args:\n        id_ (str): The ID for the action button.\n        *args: Arguments to be passed to the popover.\n\n    Returns:\n        A Shiny UI popover element.\n    \"\"\"\n    return ui.popover(\n        ui.input_action_button(id_, \"Configure plot\", icon=icon(\"gear\")),\n        *args,\n        title=\"Options\",\n        placement=\"bottom\"\n    )\n</code></pre>"},{"location":"reference/pathogenx/app/utils/#pathogenx.app.utils.nice_name","title":"<code>nice_name(name, replace_chars=('_', '.'), replace_with=' ')</code>","text":"<p>Formats a string into a human-readable 'nice' name.</p> <p>This is done by replacing specified characters and converting to title case.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The string to format.</p> required <code>replace_chars</code> <code>tuple[str]</code> <p>A tuple of characters to replace. Defaults to ('_', '.').</p> <code>('_', '.')</code> <code>replace_with</code> <code>str</code> <p>The character to replace with. Defaults to ' '.</p> <code>' '</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted string.</p> Source code in <code>pathogenx/app/utils.py</code> <pre><code>def nice_name(name: str, replace_chars: tuple[str] = ('_', '.'), replace_with: str = ' ') -&gt; str:\n    \"\"\"Formats a string into a human-readable 'nice' name.\n\n    This is done by replacing specified characters and converting to title case.\n\n    Args:\n        name (str): The string to format.\n        replace_chars (tuple[str], optional): A tuple of characters to replace.\n            Defaults to ('_', '.').\n        replace_with (str, optional): The character to replace with.\n            Defaults to ' '.\n\n    Returns:\n        str: The formatted string.\n    \"\"\"\n    for old in replace_chars:\n        name = name.replace(old, replace_with)\n    return name.title()\n</code></pre>"},{"location":"reference/pathogenx/app/utils/#pathogenx.app.utils.plural_name","title":"<code>plural_name(name, default='s', niceify=False, *args, **kwargs)</code>","text":"<p>Converts a singular noun to its plural form.</p> <p>Handles common English pluralization rules.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The noun to pluralize.</p> required <code>default</code> <code>str</code> <p>The default plural suffix. Defaults to 's'.</p> <code>'s'</code> <code>niceify</code> <code>bool</code> <p>Whether to format the name using nice_name() before pluralizing. Defaults to False.</p> <code>False</code> <code>*args</code> <p>Additional arguments to pass to nice_name().</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to nice_name().</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The pluralized noun.</p> Source code in <code>pathogenx/app/utils.py</code> <pre><code>def plural_name(name: str, default: str = 's', niceify: bool=False, *args, **kwargs) -&gt; str:\n    \"\"\"Converts a singular noun to its plural form.\n\n    Handles common English pluralization rules.\n\n    Args:\n        name (str): The noun to pluralize.\n        default (str, optional): The default plural suffix. Defaults to 's'.\n        niceify (bool, optional): Whether to format the name using nice_name()\n            before pluralizing. Defaults to False.\n        *args: Additional arguments to pass to nice_name().\n        **kwargs: Additional keyword arguments to pass to nice_name().\n\n    Returns:\n        str: The pluralized noun.\n    \"\"\"\n    if niceify:\n        name = nice_name(name, *args, **kwargs)\n    if name.endswith('us'):\n        return name[:-2] + 'i'\n    elif name.endswith('y'):\n        return name[:-1] + 'ies'\n    elif name.endswith('s'):\n        return name\n    return name + default\n</code></pre>"},{"location":"reference/pathogenx/calculators/","title":"pathogenx.calculators","text":"<p>Module for calculating insights from genotyping data such as prevalence.</p>"},{"location":"reference/pathogenx/calculators/#pathogenx.calculators.Calculator","title":"<code>Calculator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all calculators.</p> Source code in <code>pathogenx/calculators.py</code> <pre><code>class Calculator(ABC):\n    \"\"\"Abstract base class for all calculators.\"\"\"\n    def __init__(self, model: 'ModelResult' = None):\n        \"\"\"Initializes the Calculator.\n\n        Args:\n            model (ModelResult, optional): A model result to be used by the\n                calculator. Defaults to None.\n        \"\"\"\n        self.model = model\n\n    @abstractmethod\n    def calculate(self, dataset: Dataset):\n        \"\"\"Abstract method to perform a calculation on a dataset.\n\n        Args:\n            dataset (Dataset): The dataset to perform the calculation on.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/pathogenx/calculators/#pathogenx.calculators.Calculator.__init__","title":"<code>__init__(model=None)</code>","text":"<p>Initializes the Calculator.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ModelResult</code> <p>A model result to be used by the calculator. Defaults to None.</p> <code>None</code> Source code in <code>pathogenx/calculators.py</code> <pre><code>def __init__(self, model: 'ModelResult' = None):\n    \"\"\"Initializes the Calculator.\n\n    Args:\n        model (ModelResult, optional): A model result to be used by the\n            calculator. Defaults to None.\n    \"\"\"\n    self.model = model\n</code></pre>"},{"location":"reference/pathogenx/calculators/#pathogenx.calculators.Calculator.calculate","title":"<code>calculate(dataset)</code>  <code>abstractmethod</code>","text":"<p>Abstract method to perform a calculation on a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset</code> <p>The dataset to perform the calculation on.</p> required Source code in <code>pathogenx/calculators.py</code> <pre><code>@abstractmethod\ndef calculate(self, dataset: Dataset):\n    \"\"\"Abstract method to perform a calculation on a dataset.\n\n    Args:\n        dataset (Dataset): The dataset to perform the calculation on.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pathogenx/calculators/#pathogenx.calculators.CalculatorResult","title":"<code>CalculatorResult</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for calculator results.</p> <p>Designed such that we can infer the parameters of the calculator used to generate the result, without needing the instance itself.</p> Source code in <code>pathogenx/calculators.py</code> <pre><code>class CalculatorResult(ABC):\n    \"\"\"\n    Abstract base class for calculator results.\n\n    Designed such that we can infer the parameters of the calculator\n    used to generate the result, without needing the instance itself.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initializes the CalculatorResult.\"\"\"\n        self._data = None\n\n    @property\n    def data(self) -&gt; pd.DataFrame:\n        \"\"\"Returns a copy of the result data to prevent accidental modification.\"\"\"\n        return self._data.copy() if self._data is not None else pd.DataFrame()\n\n    @data.setter\n    def data(self, value: pd.DataFrame):\n        \"\"\"Sets the result data stored as a private property.\"\"\"\n        self._data = value\n\n    def __len__(self):\n        \"\"\"Returns the number of rows in the result data.\n\n        Returns:\n            int: The length of the result data DataFrame.\n        \"\"\"\n        return 0 if self._data is None else len(self._data)\n</code></pre>"},{"location":"reference/pathogenx/calculators/#pathogenx.calculators.CalculatorResult.data","title":"<code>data</code>  <code>property</code> <code>writable</code>","text":"<p>Returns a copy of the result data to prevent accidental modification.</p>"},{"location":"reference/pathogenx/calculators/#pathogenx.calculators.CalculatorResult.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the CalculatorResult.</p> Source code in <code>pathogenx/calculators.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes the CalculatorResult.\"\"\"\n    self._data = None\n</code></pre>"},{"location":"reference/pathogenx/calculators/#pathogenx.calculators.CalculatorResult.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of rows in the result data.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The length of the result data DataFrame.</p> Source code in <code>pathogenx/calculators.py</code> <pre><code>def __len__(self):\n    \"\"\"Returns the number of rows in the result data.\n\n    Returns:\n        int: The length of the result data DataFrame.\n    \"\"\"\n    return 0 if self._data is None else len(self._data)\n</code></pre>"},{"location":"reference/pathogenx/calculators/#pathogenx.calculators.PrevalenceCalculator","title":"<code>PrevalenceCalculator</code>","text":"<p>               Bases: <code>Calculator</code></p> <p>Calculates raw and adjusted prevalence statistics from a dataset.</p> <p>This class is designed to replicate the logic of the R 'prevalence' package using pandas for efficient data manipulation.</p> <p>Attributes:</p> Name Type Description <code>stratify_by</code> <code>list[str]</code> <p>List of columns to stratify the analysis by.</p> <code>adjust_for</code> <code>list[str]</code> <p>List of columns for adjustment (e.g., 'Cluster').</p> <code>n_distinct</code> <code>list[str]</code> <p>List of columns to calculate distinct counts for.</p> <code>denominator</code> <code>str</code> <p>Column to use as the primary grouping for denominators. If None, the first column in stratify_by is used.</p> Source code in <code>pathogenx/calculators.py</code> <pre><code>class PrevalenceCalculator(Calculator):\n    \"\"\"\n    Calculates raw and adjusted prevalence statistics from a dataset.\n\n    This class is designed to replicate the logic of the R 'prevalence'\n    package using pandas for efficient data manipulation.\n\n    Attributes:\n        stratify_by (list[str]): List of columns to stratify the analysis by.\n        adjust_for (list[str], optional): List of columns for adjustment (e.g., 'Cluster').\n        n_distinct (list[str], optional): List of columns to calculate distinct counts for.\n        denominator (str, optional): Column to use as the primary grouping for\n            denominators. If None, the first column in stratify_by is used.\n    \"\"\"\n    def __init__(self, stratify_by: List[str], adjust_for: List[str] = None, n_distinct: List[str] = None,\n                 denominator: str = None):\n        \"\"\"Initializes the PrevalenceCalculator.\n\n        Args:\n            stratify_by (List[str]): Columns to stratify the analysis by.\n            adjust_for (List[str], optional): Columns for adjustment. Defaults to None.\n            n_distinct (List[str], optional): Columns to calculate distinct counts for.\n                Defaults to None.\n            denominator (str, optional): Column for primary grouping for denominators.\n                Defaults to None.\n\n        Raises:\n            ValueError: If 'denominator' is provided but not in 'stratify_by'.\n        \"\"\"\n        super().__init__()\n\n        if denominator and denominator not in stratify_by:\n            raise ValueError(\"If provided, 'denominator' must be in 'stratify_by'.\")\n\n        # Set denominator if not provided and stratification has more than one level\n        if not denominator and len(stratify_by) &gt; 1:\n            denominator = stratify_by[0]\n\n        self.stratify_by: List[str] = stratify_by\n        self.adjust_for: Optional[List[str]] = adjust_for\n        self.n_distinct: Optional[List[str]] = n_distinct\n        self.denominator: Optional[str] = denominator\n\n    def calculate(self, dataset: Union[Dataset, pd.DataFrame]) -&gt; PrevalenceResult:\n        \"\"\"Calculates prevalence statistics on a dataset.\n\n        This method computes raw and optionally adjusted counts, proportions,\n        standard errors, and 95% confidence intervals (using the Wilson score\n        interval method) for the specified strata. It can also calculate\n        distinct counts for designated columns and rank prevalences within\n        denominator groups.\n\n        Args:\n            dataset (Union[Dataset, pd.DataFrame]): The dataset on which to\n                calculate prevalence.\n\n        Returns:\n            PrevalenceResult: An object containing the calculated prevalence data\n                and metadata about the calculation.\n\n        Raises:\n            TypeError: If the dataset is not a pandas DataFrame or a\n                pathogenx Dataset object.\n        \"\"\"\n        if isinstance(dataset, Dataset):\n            data = dataset.data  # Gets a copy from the @property\n        elif isinstance(dataset, pd.DataFrame):\n            data = dataset.copy()\n        else:\n            raise TypeError(\"dataset must be of type Dataset or pd.DataFrame\")\n\n        # 1. Calculate Denominators\n        denominators = {}\n        adj_col = self.adjust_for[0] if self.adjust_for else None\n        if self.denominator:\n            denom_groups = data.groupby(self.denominator)\n            denominators['raw'] = denom_groups.size().rename('denominator.raw')\n            if adj_col:\n                denominators['adj'] = denom_groups[adj_col].nunique().rename('denominator.adj')\n        else:\n            denominators['raw'] = pd.Series([len(data)], name='denominator.raw')\n            if adj_col:\n                denominators['adj'] = pd.Series([data[adj_col].nunique()], name='denominator.adj')\n\n        # 2. Calculate Counts within strata\n        strata_groups = data.groupby(self.stratify_by)\n        result_data = strata_groups.size().to_frame('count.raw')\n        if adj_col:\n            result_data['count.adj'] = strata_groups[adj_col].nunique()\n        if self.n_distinct:\n            for col in self.n_distinct:\n                result_data[f'# {col}'] = strata_groups[col].nunique()\n\n        result_data = result_data.reset_index()\n\n        # 3. Join denominators and calculate proportions\n        if self.denominator:\n            result_data = result_data.merge(denominators['raw'], on=self.denominator, how='left')\n            if adj_col:\n                result_data = result_data.merge(denominators['adj'], on=self.denominator, how='left')\n        else:\n            result_data['denominator.raw'] = denominators['raw'][0]\n            if adj_col:\n                result_data['denominator.adj'] = denominators['adj'][0]\n\n        # 4. Calculate Proportions, SE, and CI\n        for col_type in denominators:\n            count = result_data[f'count.{col_type}']\n            denom = result_data[f'denominator.{col_type}']\n            for x, y in zip(('prop', 'se', 'lower', 'upper'), _wilson_score_interval(count, denom)):\n                result_data[f'{x}.{col_type}'] = y\n\n        # 5. Sort data\n        sort_by = ['denominator.adj', 'count.adj'] if self.adjust_for else ['denominator.raw', 'count.raw']\n        result_data = result_data.sort_values(by=sort_by, ascending=False)\n\n        # 6. Calculate Ranks\n        rank_groups = result_data.groupby(self.denominator) if self.denominator else result_data\n        for col_type in denominators:\n            result_data[f'rank.{col_type}'] = rank_groups[f'prop.{col_type}'].rank(method='first', ascending=False)\n\n        result = PrevalenceResult.from_calculator(self)\n        result.data = result_data  # Set the result data\n        return result\n</code></pre>"},{"location":"reference/pathogenx/calculators/#pathogenx.calculators.PrevalenceCalculator.__init__","title":"<code>__init__(stratify_by, adjust_for=None, n_distinct=None, denominator=None)</code>","text":"<p>Initializes the PrevalenceCalculator.</p> <p>Parameters:</p> Name Type Description Default <code>stratify_by</code> <code>List[str]</code> <p>Columns to stratify the analysis by.</p> required <code>adjust_for</code> <code>List[str]</code> <p>Columns for adjustment. Defaults to None.</p> <code>None</code> <code>n_distinct</code> <code>List[str]</code> <p>Columns to calculate distinct counts for. Defaults to None.</p> <code>None</code> <code>denominator</code> <code>str</code> <p>Column for primary grouping for denominators. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If 'denominator' is provided but not in 'stratify_by'.</p> Source code in <code>pathogenx/calculators.py</code> <pre><code>def __init__(self, stratify_by: List[str], adjust_for: List[str] = None, n_distinct: List[str] = None,\n             denominator: str = None):\n    \"\"\"Initializes the PrevalenceCalculator.\n\n    Args:\n        stratify_by (List[str]): Columns to stratify the analysis by.\n        adjust_for (List[str], optional): Columns for adjustment. Defaults to None.\n        n_distinct (List[str], optional): Columns to calculate distinct counts for.\n            Defaults to None.\n        denominator (str, optional): Column for primary grouping for denominators.\n            Defaults to None.\n\n    Raises:\n        ValueError: If 'denominator' is provided but not in 'stratify_by'.\n    \"\"\"\n    super().__init__()\n\n    if denominator and denominator not in stratify_by:\n        raise ValueError(\"If provided, 'denominator' must be in 'stratify_by'.\")\n\n    # Set denominator if not provided and stratification has more than one level\n    if not denominator and len(stratify_by) &gt; 1:\n        denominator = stratify_by[0]\n\n    self.stratify_by: List[str] = stratify_by\n    self.adjust_for: Optional[List[str]] = adjust_for\n    self.n_distinct: Optional[List[str]] = n_distinct\n    self.denominator: Optional[str] = denominator\n</code></pre>"},{"location":"reference/pathogenx/calculators/#pathogenx.calculators.PrevalenceCalculator.calculate","title":"<code>calculate(dataset)</code>","text":"<p>Calculates prevalence statistics on a dataset.</p> <p>This method computes raw and optionally adjusted counts, proportions, standard errors, and 95% confidence intervals (using the Wilson score interval method) for the specified strata. It can also calculate distinct counts for designated columns and rank prevalences within denominator groups.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Union[Dataset, DataFrame]</code> <p>The dataset on which to calculate prevalence.</p> required <p>Returns:</p> Name Type Description <code>PrevalenceResult</code> <code>PrevalenceResult</code> <p>An object containing the calculated prevalence data and metadata about the calculation.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the dataset is not a pandas DataFrame or a pathogenx Dataset object.</p> Source code in <code>pathogenx/calculators.py</code> <pre><code>def calculate(self, dataset: Union[Dataset, pd.DataFrame]) -&gt; PrevalenceResult:\n    \"\"\"Calculates prevalence statistics on a dataset.\n\n    This method computes raw and optionally adjusted counts, proportions,\n    standard errors, and 95% confidence intervals (using the Wilson score\n    interval method) for the specified strata. It can also calculate\n    distinct counts for designated columns and rank prevalences within\n    denominator groups.\n\n    Args:\n        dataset (Union[Dataset, pd.DataFrame]): The dataset on which to\n            calculate prevalence.\n\n    Returns:\n        PrevalenceResult: An object containing the calculated prevalence data\n            and metadata about the calculation.\n\n    Raises:\n        TypeError: If the dataset is not a pandas DataFrame or a\n            pathogenx Dataset object.\n    \"\"\"\n    if isinstance(dataset, Dataset):\n        data = dataset.data  # Gets a copy from the @property\n    elif isinstance(dataset, pd.DataFrame):\n        data = dataset.copy()\n    else:\n        raise TypeError(\"dataset must be of type Dataset or pd.DataFrame\")\n\n    # 1. Calculate Denominators\n    denominators = {}\n    adj_col = self.adjust_for[0] if self.adjust_for else None\n    if self.denominator:\n        denom_groups = data.groupby(self.denominator)\n        denominators['raw'] = denom_groups.size().rename('denominator.raw')\n        if adj_col:\n            denominators['adj'] = denom_groups[adj_col].nunique().rename('denominator.adj')\n    else:\n        denominators['raw'] = pd.Series([len(data)], name='denominator.raw')\n        if adj_col:\n            denominators['adj'] = pd.Series([data[adj_col].nunique()], name='denominator.adj')\n\n    # 2. Calculate Counts within strata\n    strata_groups = data.groupby(self.stratify_by)\n    result_data = strata_groups.size().to_frame('count.raw')\n    if adj_col:\n        result_data['count.adj'] = strata_groups[adj_col].nunique()\n    if self.n_distinct:\n        for col in self.n_distinct:\n            result_data[f'# {col}'] = strata_groups[col].nunique()\n\n    result_data = result_data.reset_index()\n\n    # 3. Join denominators and calculate proportions\n    if self.denominator:\n        result_data = result_data.merge(denominators['raw'], on=self.denominator, how='left')\n        if adj_col:\n            result_data = result_data.merge(denominators['adj'], on=self.denominator, how='left')\n    else:\n        result_data['denominator.raw'] = denominators['raw'][0]\n        if adj_col:\n            result_data['denominator.adj'] = denominators['adj'][0]\n\n    # 4. Calculate Proportions, SE, and CI\n    for col_type in denominators:\n        count = result_data[f'count.{col_type}']\n        denom = result_data[f'denominator.{col_type}']\n        for x, y in zip(('prop', 'se', 'lower', 'upper'), _wilson_score_interval(count, denom)):\n            result_data[f'{x}.{col_type}'] = y\n\n    # 5. Sort data\n    sort_by = ['denominator.adj', 'count.adj'] if self.adjust_for else ['denominator.raw', 'count.raw']\n    result_data = result_data.sort_values(by=sort_by, ascending=False)\n\n    # 6. Calculate Ranks\n    rank_groups = result_data.groupby(self.denominator) if self.denominator else result_data\n    for col_type in denominators:\n        result_data[f'rank.{col_type}'] = rank_groups[f'prop.{col_type}'].rank(method='first', ascending=False)\n\n    result = PrevalenceResult.from_calculator(self)\n    result.data = result_data  # Set the result data\n    return result\n</code></pre>"},{"location":"reference/pathogenx/calculators/#pathogenx.calculators.PrevalenceResult","title":"<code>PrevalenceResult</code>","text":"<p>               Bases: <code>CalculatorResult</code></p> <p>Class to store the results of a <code>PrevalenceCalculator</code>.</p> <p>Attributes:</p> Name Type Description <code>stratified_by</code> <code>list[str]</code> <p>List of columns the result is stratified by, in order of strata level.</p> <code>adjusted_for</code> <code>list[str]</code> <p>List of columns the prevalences were adjusted for (e.g., 'Cluster').</p> <code>n_distinct</code> <code>list[str]</code> <p>List of columns for which distinct counts (per-strata) were generated.</p> <code>denominator</code> <code>str</code> <p>Column indicating the denominator stratum.</p> Source code in <code>pathogenx/calculators.py</code> <pre><code>class PrevalenceResult(CalculatorResult):\n    \"\"\"\n    Class to store the results of a `PrevalenceCalculator`.\n\n    Attributes:\n        stratified_by (list[str]): List of columns the result is stratified by,\n            in order of strata level.\n        adjusted_for (list[str], optional): List of columns the prevalences were\n            adjusted for (e.g., 'Cluster').\n        n_distinct (list[str], optional): List of columns for which distinct counts\n            (per-strata) were generated.\n        denominator (str, optional): Column indicating the denominator stratum.\n    \"\"\"\n    def __init__(self, stratified_by: List[str], adjusted_for: List[str] = None, n_distinct: List[str] = None,\n                 denominator: str = None):\n        \"\"\"Initializes the PrevalenceResult.\n\n        Args:\n            stratified_by (List[str]): Columns the result is stratified by.\n            adjusted_for (List[str], optional): Columns prevalences were adjusted for.\n                Defaults to None.\n            n_distinct (List[str], optional): Columns distinct counts were generated for.\n                Defaults to None.\n            denominator (str, optional): The denominator stratum. Defaults to None.\n        \"\"\"\n        super().__init__()\n        self.stratified_by: List[str] = stratified_by\n        self.adjusted_for: Optional[List[str]] = adjusted_for\n        self.n_distinct: Optional[List[str]] = n_distinct\n        self.denominator: Optional[str] = denominator\n\n    @classmethod\n    def from_calculator(cls, calculator: 'PrevalenceCalculator') -&gt; 'PrevalenceResult':\n        \"\"\"Initializes a PrevalenceResult from a PrevalenceCalculator instance.\n\n        Args:\n            calculator (PrevalenceCalculator): The calculator instance.\n\n        Returns:\n            PrevalenceResult: A new PrevalenceResult object configured with the\n                calculator's parameters.\n        \"\"\"\n        return cls(calculator.stratify_by, calculator.adjust_for, calculator.n_distinct, calculator.denominator)\n</code></pre>"},{"location":"reference/pathogenx/calculators/#pathogenx.calculators.PrevalenceResult.__init__","title":"<code>__init__(stratified_by, adjusted_for=None, n_distinct=None, denominator=None)</code>","text":"<p>Initializes the PrevalenceResult.</p> <p>Parameters:</p> Name Type Description Default <code>stratified_by</code> <code>List[str]</code> <p>Columns the result is stratified by.</p> required <code>adjusted_for</code> <code>List[str]</code> <p>Columns prevalences were adjusted for. Defaults to None.</p> <code>None</code> <code>n_distinct</code> <code>List[str]</code> <p>Columns distinct counts were generated for. Defaults to None.</p> <code>None</code> <code>denominator</code> <code>str</code> <p>The denominator stratum. Defaults to None.</p> <code>None</code> Source code in <code>pathogenx/calculators.py</code> <pre><code>def __init__(self, stratified_by: List[str], adjusted_for: List[str] = None, n_distinct: List[str] = None,\n             denominator: str = None):\n    \"\"\"Initializes the PrevalenceResult.\n\n    Args:\n        stratified_by (List[str]): Columns the result is stratified by.\n        adjusted_for (List[str], optional): Columns prevalences were adjusted for.\n            Defaults to None.\n        n_distinct (List[str], optional): Columns distinct counts were generated for.\n            Defaults to None.\n        denominator (str, optional): The denominator stratum. Defaults to None.\n    \"\"\"\n    super().__init__()\n    self.stratified_by: List[str] = stratified_by\n    self.adjusted_for: Optional[List[str]] = adjusted_for\n    self.n_distinct: Optional[List[str]] = n_distinct\n    self.denominator: Optional[str] = denominator\n</code></pre>"},{"location":"reference/pathogenx/calculators/#pathogenx.calculators.PrevalenceResult.from_calculator","title":"<code>from_calculator(calculator)</code>  <code>classmethod</code>","text":"<p>Initializes a PrevalenceResult from a PrevalenceCalculator instance.</p> <p>Parameters:</p> Name Type Description Default <code>calculator</code> <code>PrevalenceCalculator</code> <p>The calculator instance.</p> required <p>Returns:</p> Name Type Description <code>PrevalenceResult</code> <code>PrevalenceResult</code> <p>A new PrevalenceResult object configured with the calculator's parameters.</p> Source code in <code>pathogenx/calculators.py</code> <pre><code>@classmethod\ndef from_calculator(cls, calculator: 'PrevalenceCalculator') -&gt; 'PrevalenceResult':\n    \"\"\"Initializes a PrevalenceResult from a PrevalenceCalculator instance.\n\n    Args:\n        calculator (PrevalenceCalculator): The calculator instance.\n\n    Returns:\n        PrevalenceResult: A new PrevalenceResult object configured with the\n            calculator's parameters.\n    \"\"\"\n    return cls(calculator.stratify_by, calculator.adjust_for, calculator.n_distinct, calculator.denominator)\n</code></pre>"},{"location":"reference/pathogenx/cli/","title":"pathogenx.cli","text":"<p>Module for managing the CLI layer on top of the API; also contains the CLI entry point under <code>main()</code>.</p>"},{"location":"reference/pathogenx/cli/#pathogenx.cli.main","title":"<code>main()</code>","text":"<p>Main command-line interface entry point.</p> <p>Parses command-line arguments and executes the appropriate command.</p> Source code in <code>pathogenx/cli.py</code> <pre><code>def main():\n    \"\"\"Main command-line interface entry point.\n\n    Parses command-line arguments and executes the appropriate command.\n    \"\"\"\n    parser = ArgumentParser(\n        description=_LOGO, usage=\"{prog}s &lt;command&gt;\", add_help=False, prog=RESOURCES.package,\n        formatter_class=RawDescriptionHelpFormatter\n    )\n    subparsers = parser.add_subparsers(\n        title=bold('Command'), dest='command', metavar='&lt;command&gt;', required=True, help=None\n    )\n    # Add subparsers\n    prevalence_parser(subparsers)\n    if 'pathogenx.app' in RESOURCES.optional_packages:\n        from pathogenx.app.utils import app_cli_parser\n        app_cli_parser(subparsers, RESOURCES.package, _LOGO, RawTextHelpFormatter, _VERSION)\n    # Add options\n    opts = parser.add_argument_group(bold('Other options'), '')\n    opts.add_argument('-v', '--version', help='Show version number and exit', action='version', version=_VERSION)\n    opts.add_argument('-h', '--help', help='Show this help message and exit', action='help')\n    # Parse args\n    args = parser.parse_args()\n    # Run the appropriate command\n    if args.command == 'prevalence':\n        from pathogenx.io import GenotypeFile, MetaFile, DistFile\n        from pathogenx.dataset import Dataset\n        from pathogenx.calculators import PrevalenceCalculator\n        metadata_file, distance_file = None, None\n        genotype_file = GenotypeFile.from_flavour(args.genotypes, args.genotype_flavour)\n        if args.metadata is not None:\n            metadata_file = MetaFile.from_flavour(args.metadata, args.metadata_flavour)\n        if args.distances is not None:\n            distance_file = DistFile.from_flavour(args.distances, args.distance_flavour)\n\n        dataset = Dataset.from_files(genotype_file, metadata_file, distance_file)\n        if dataset.distances is not None:\n            dataset.calculate_clusters(distance=args.snp_distance)\n        calculator = PrevalenceCalculator(args.strata, args.adjust_for, args.n_distinct, args.denominator)\n        result = calculator.calculate(dataset)\n        result.data.to_csv(stdout, sep='\\t', index=False)\n    elif args.command == 'app':\n        from shiny import run_app\n        run_app(\n            \"pathogenx.app:app\", host=args.host, port=args.port, autoreload_port=args.autoreload_port,\n            reload=args.reload, ws_max_size=args.ws_max_size, launch_browser=args.launch_browser,\n            dev_mode=args.dev_mode, factory=args.factory\n        )\n</code></pre>"},{"location":"reference/pathogenx/cli/#pathogenx.cli.prevalence_parser","title":"<code>prevalence_parser(subparsers)</code>","text":"<p>Sets up the argument parser for the 'prevalence' command.</p> <p>Parameters:</p> Name Type Description Default <code>subparsers</code> <p>The subparsers object from <code>ArgumentParser.add_subparsers()</code>.</p> required Source code in <code>pathogenx/cli.py</code> <pre><code>def prevalence_parser(subparsers):\n    \"\"\"Sets up the argument parser for the 'prevalence' command.\n\n    Args:\n        subparsers: The subparsers object from `ArgumentParser.add_subparsers()`.\n    \"\"\"\n    name, desc = 'prevalence', 'Calculate prevalence in a dataset'\n    parser = subparsers.add_parser(\n        name, description=_LOGO, prog=f'{RESOURCES.package} {name}', formatter_class=RawTextHelpFormatter, help=desc,\n        usage=\"%(prog)s &lt;genotypes&gt; &lt;strata&gt; [options]\", add_help=False\n    )\n    inputs = parser.add_argument_group(bold('Inputs'), '')\n    inputs.add_argument('genotypes', metavar='&lt;genotypes&gt;', help='Genotype file', type=Path)\n    inputs.add_argument('strata', metavar='&lt;strata&gt;', help='List of columns to stratify the analysis by', nargs='+')\n    inputs.add_argument('--metadata', metavar='', help='Optional metadata file', nargs='?', type=Path)\n    inputs.add_argument('--distances', metavar='', help='Optional distance file', nargs='?', type=Path)\n    inputs.add_argument('--genotype-flavour', help='Genotype file flavour (default: %(default)s)\\n'\n                                                   '(choices: %(choices)s)', metavar='',\n                        choices=get_args(_GENOTYPE_FLAVOURS), default='pw-kleborate')\n    inputs.add_argument('--metadata-flavour', help='Metadata file flavour (default: %(default)s)\\n'\n                                                   '(choices: %(choices)s)', metavar='',\n                        choices=get_args(_META_FLAVOURS), default='pw-metadata')\n    inputs.add_argument('--distance-flavour', help='Distance file flavour (default: %(default)s)\\n'\n                                                   '(choices: %(choices)s)', metavar='',\n                        choices=get_args(_DIST_FLAVOURS), default='pw-dist')\n\n    calc = parser.add_argument_group(bold('Calculator options'), '')\n    calc.add_argument('--adjust-for', help='Optional list of columns for adjustment (e.g., Cluster)', nargs='*', metavar='')\n    calc.add_argument('--n-distinct', help='Optional list of columns to calculate distinct counts for', nargs='*', metavar='')\n    calc.add_argument('--denominator', help='Optional column to use as the primary grouping for denominators\\n'\n                                            'If None, the first column in stratify-by is used', metavar='')\n\n    calc = parser.add_argument_group(bold('Clustering options'), '')\n    calc.add_argument('--snp-distance', type=int, default=20, metavar='',\n                      help='The maximum distance for two samples to be considered connected.\\n'\n                           'Only used when `method` is connected_components (default: %(default)s)')\n\n    opts = parser.add_argument_group(bold('Other options'), '')\n    opts.add_argument('-v', '--version', help='Show version number and exit', action='version', version=_VERSION)\n    opts.add_argument('-h', '--help', help='Show this help message and exit', action='help')\n</code></pre>"},{"location":"reference/pathogenx/dataset/","title":"pathogenx.dataset","text":""},{"location":"reference/pathogenx/dataset/#pathogenx.dataset.Dataset","title":"<code>Dataset</code>","text":"<p>A class to encapsulate genotype, metadata, and distance data for pathogen analysis.</p> <p>This class provides a unified interface for accessing and manipulating related datasets, ensuring data integrity and consistency across different analysis steps. It supports loading data from various file formats and can perform operations like clustering.</p> <p>Attributes:</p> Name Type Description <code>_data</code> <code>DataFrame</code> <p>The primary DataFrame holding genotype and metadata.</p> <code>distances</code> <code>coo_matrix | None</code> <p>Sparse distance matrix, if provided.</p> <code>genotype_columns</code> <code>set[str]</code> <p>Names of columns containing genotype data.</p> <code>metadata_columns</code> <code>set[str]</code> <p>Names of columns containing metadata.</p> Source code in <code>pathogenx/dataset.py</code> <pre><code>class Dataset:\n    \"\"\"\n    A class to encapsulate genotype, metadata, and distance data for pathogen analysis.\n\n    This class provides a unified interface for accessing and manipulating related\n    datasets, ensuring data integrity and consistency across different analysis\n    steps. It supports loading data from various file formats and can perform\n    operations like clustering.\n\n    Attributes:\n        _data (pd.DataFrame): The primary DataFrame holding genotype and metadata.\n        distances (coo_matrix | None): Sparse distance matrix, if provided.\n        genotype_columns (set[str]): Names of columns containing genotype data.\n        metadata_columns (set[str]): Names of columns containing metadata.\n    \"\"\"\n    def __init__(self, genotypes: pd.DataFrame, metadata: pd.DataFrame = None,\n                 distances: tuple[coo_matrix, list[str]] = None, name: str = 'unknown',\n                 genotype_columns: set[str] = None, metadata_columns: set[str] = None):\n        # Add genotype data and set dataset name ----------------------------------------\n        self._data = genotypes\n        self._data['Dataset'] = name\n        # Add metadata ------------------------------------------------------------------\n        if metadata is not None:\n            self._data = self._data.join(metadata, how='left')\n        # Add distances ------------------------------------------------------------------\n        if distances is not None:\n            distances, index = distances  # Unpack tuple\n            for sample in self._data.index:  # Check all samples are present in data\n                if sample not in index:\n                    raise DatasetError(f'Sample {sample} not in index')\n            self._data = self._data.reindex(index)  # Reorder index to match distance matrix\n            self.distances = distances.tocsr()  # Convert to CSR for efficient row slicing\n        else:\n            self.distances = None\n        # Add columns -------------------------------------------------------------------\n        self.metadata_columns: set[str] = metadata_columns or (set(metadata.columns) if metadata is not None else set())\n        self.metadata_columns.add('Dataset')\n        self.genotype_columns: set[str] = (genotype_columns or set(genotypes.columns)) - self.metadata_columns\n\n    def __repr__(self) -&gt; str:\n        return (f'Dataset({len(self._data)} samples {\"with\" if self.distances is not None else \"without\"} distances, '\n                f'{len(self.genotype_columns)} genotypes, '\n                f'{len(self.metadata_columns)} metadata variables)')\n\n    def __len__(self):\n        return len(self._data)\n\n    def __contains__(self, sample: str) -&gt; bool:\n        return sample in self._data.index\n\n    def __getitem__(self, item):\n        return self._data[item]\n\n    def __iter__(self):\n        return self._data.itertuples()\n\n    @classmethod\n    def from_files(cls, genotypes: GenotypeFile, metadata: MetaFile = None, distances: DistFile = None, name: str = None):\n        \"\"\"\n        Initialises a `Dataset` instance from `_InputFile` instances.\n\n        Parameters:\n            genotypes (GenotypeFile): An instance of `GenotypeFile` containing genotype data.\n            metadata (MetaFile, optional): An instance of `MetaFile` containing metadata. Defaults to None.\n            distances (DistFile, optional): An instance of `DistFile` containing distance data. Defaults to None.\n            name (str, optional): A name for the dataset. Defaults to None, in which case the name will be\n                                  inferred from the genotype file.\n\n        Returns:\n            cls: A new `Dataset` instance populated with the provided data.\n        \"\"\"\n        return cls(\n            genotypes.load(),\n            metadata.load() if metadata else None,\n            distances.load() if distances else None,\n            name\n        )\n\n    @classmethod\n    def from_pathogenwatch(cls, path: Path) -&gt; 'Dataset':\n        \"\"\"\n        Initialises a `Dataset` instance from a Pathogenwatch folder.\n\n        This method expects a folder containing CSV files downloaded from Pathogenwatch,\n        specifically looking for files named according to the Pathogenwatch convention\n        (e.g., `pathogenwatch-species-collection-analysis.csv`). It automatically\n        identifies and loads genotype, metadata, and distance files.\n\n        Parameters:\n            path (Path): The path to the directory containing Pathogenwatch CSV files.\n\n        Returns:\n            Dataset: A new `Dataset` instance populated with data from the Pathogenwatch files.\n\n        Raises:\n            DatasetError: If no relevant Pathogenwatch files are found or if genotype data is missing.\n        \"\"\"\n        r = regex(r'.*pathogenwatch-(?P&lt;species&gt;\\w+)-(?P&lt;collection&gt;[\\w-]+)-'\n                  r'(?P&lt;analysis&gt;(kleborate|difference-matrix|metadata))\\.csv')\n        if not (files := [match for file in path.glob('*.csv') if (match := r.match(file.name))]):\n            raise DatasetError(f'Could not find any files in {path}')\n\n        dataset, files = next(grouper(files, 2))\n\n        files = {k: path / next(v).string for k, v in grouper(files, 3)}\n        genotypes, metadata, distances = files.get('kleborate'), files.get('metadata'), files.get('difference-matrix')\n        if genotypes is None:\n            raise DatasetError(f'Could not find any genotypes in {path} for {dataset}')\n\n        return cls.from_files(\n            GenotypeFile.from_flavour(genotypes, 'pw-kleborate'),\n            MetaFile.from_flavour(metadata, 'pw-metadata') if metadata else None,\n            DistFile.from_flavour(distances, 'pw-dist') if distances else None,\n            dataset\n        )\n\n    @property\n    def data(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Returns a copy of the internal DataFrame to prevent unintended modification of the Dataset's state.\n        \"\"\"\n        return self._data.copy()\n\n    def samples(self):\n        \"\"\"Returns a list of sample names (the index of the internal DataFrame).\"\"\"\n        return self._data.index\n\n    def calculate_clusters(self, method: Literal['connected_components', 'variables'] = 'connected_components',\n                           group_by: list[str] = None, distance: int = 20) -&gt; pd.Series:\n        \"\"\"Calculates clusters and adds/overwrites the 'Cluster' column.\n\n        This method provides two main strategies for clustering: finding connected\n        components in a distance graph or grouping by categorical variables. The\n        resulting cluster labels are stored in a 'Cluster' column in the internal\n        DataFrame. If the column already exists, it will be overwritten and a\n        `DatasetWarning` will be issued.\n\n        Args:\n            method (Literal['connected_components', 'variables'], optional):\n                The clustering strategy to use. Defaults to 'connected_components'.\n                - 'connected_components': Finds clusters based on a distance\n                  threshold. Requires a distance matrix.\n                - 'variables': Groups samples based on the specified `group_by`\n                  columns.\n            group_by (list[str], optional): A list of column names to group by.\n                If `None` with 'variables', each sample gets a unique cluster.\n                If `None` with 'connected_components', the entire dataset is\n                treated as a single group. Defaults to None.\n            distance (int, optional): The maximum distance for two samples to be\n                considered connected. Only used when `method` is\n                'connected_components'. Defaults to 20.\n\n        Returns:\n            A pandas Series containing the calculated cluster labels for each sample.\n\n        Raises:\n            DatasetError: If `method` is 'connected_components' and no distance\n                matrix is available in the Dataset.\n            ValueError: If an unknown `method` is provided.\n        \"\"\"\n        if 'Cluster' in self._data.columns:\n            warn(\"'Cluster' column already exists and will be overwritten.\", DatasetWarning)\n\n        if method == 'variables':\n            self._data['Cluster'] = 'cluster_' + (self._data.groupby(group_by).ngroup() + 1).astype(str) \\\n                if group_by else [f'cluster_{i + 1}' for i in range(len(self._data))]\n\n        elif method == 'connected_components':\n            if self.distances is None:\n                raise DatasetError(\"Cannot calculate connected components: no distance matrix found in Dataset.\")\n\n            cluster_labels = pd.Series(index=self._data.index, dtype='object')\n            global_cluster_counter = 1\n\n            # Determine groups: either from group_by or a single group for the whole dataset\n            groups = self._data.groupby(group_by) if group_by else [('all', self._data)]\n\n            for _, group_df in groups:\n                if group_df.empty:\n                    continue\n\n                # Get integer indices for samples in this group\n                group_indices = self._data.index.get_indexer(group_df.index)\n\n                # Efficiently subset the sparse graph and filter by distance\n                subgraph = self.distances[group_indices, :][:, group_indices]\n                subgraph.data[subgraph.data &gt; distance] = 0\n                subgraph.eliminate_zeros()\n\n                _, local_labels = connected_components(csgraph=subgraph, directed=False, return_labels=True)\n\n                if local_labels.size &gt; 0:\n                    cluster_labels.loc[group_df.index] = [f\"cluster_{l + global_cluster_counter}\" for l in local_labels]\n                    global_cluster_counter += local_labels.max() + 1\n\n            self._data['Cluster'] = cluster_labels\n\n        else:\n            raise ValueError(f\"Unknown method: {method}\")\n\n        return self._data['Cluster']\n</code></pre>"},{"location":"reference/pathogenx/dataset/#pathogenx.dataset.Dataset.data","title":"<code>data</code>  <code>property</code>","text":"<p>Returns a copy of the internal DataFrame to prevent unintended modification of the Dataset's state.</p>"},{"location":"reference/pathogenx/dataset/#pathogenx.dataset.Dataset.calculate_clusters","title":"<code>calculate_clusters(method='connected_components', group_by=None, distance=20)</code>","text":"<p>Calculates clusters and adds/overwrites the 'Cluster' column.</p> <p>This method provides two main strategies for clustering: finding connected components in a distance graph or grouping by categorical variables. The resulting cluster labels are stored in a 'Cluster' column in the internal DataFrame. If the column already exists, it will be overwritten and a <code>DatasetWarning</code> will be issued.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Literal['connected_components', 'variables']</code> <p>The clustering strategy to use. Defaults to 'connected_components'. - 'connected_components': Finds clusters based on a distance   threshold. Requires a distance matrix. - 'variables': Groups samples based on the specified <code>group_by</code>   columns.</p> <code>'connected_components'</code> <code>group_by</code> <code>list[str]</code> <p>A list of column names to group by. If <code>None</code> with 'variables', each sample gets a unique cluster. If <code>None</code> with 'connected_components', the entire dataset is treated as a single group. Defaults to None.</p> <code>None</code> <code>distance</code> <code>int</code> <p>The maximum distance for two samples to be considered connected. Only used when <code>method</code> is 'connected_components'. Defaults to 20.</p> <code>20</code> <p>Returns:</p> Type Description <code>Series</code> <p>A pandas Series containing the calculated cluster labels for each sample.</p> <p>Raises:</p> Type Description <code>DatasetError</code> <p>If <code>method</code> is 'connected_components' and no distance matrix is available in the Dataset.</p> <code>ValueError</code> <p>If an unknown <code>method</code> is provided.</p> Source code in <code>pathogenx/dataset.py</code> <pre><code>def calculate_clusters(self, method: Literal['connected_components', 'variables'] = 'connected_components',\n                       group_by: list[str] = None, distance: int = 20) -&gt; pd.Series:\n    \"\"\"Calculates clusters and adds/overwrites the 'Cluster' column.\n\n    This method provides two main strategies for clustering: finding connected\n    components in a distance graph or grouping by categorical variables. The\n    resulting cluster labels are stored in a 'Cluster' column in the internal\n    DataFrame. If the column already exists, it will be overwritten and a\n    `DatasetWarning` will be issued.\n\n    Args:\n        method (Literal['connected_components', 'variables'], optional):\n            The clustering strategy to use. Defaults to 'connected_components'.\n            - 'connected_components': Finds clusters based on a distance\n              threshold. Requires a distance matrix.\n            - 'variables': Groups samples based on the specified `group_by`\n              columns.\n        group_by (list[str], optional): A list of column names to group by.\n            If `None` with 'variables', each sample gets a unique cluster.\n            If `None` with 'connected_components', the entire dataset is\n            treated as a single group. Defaults to None.\n        distance (int, optional): The maximum distance for two samples to be\n            considered connected. Only used when `method` is\n            'connected_components'. Defaults to 20.\n\n    Returns:\n        A pandas Series containing the calculated cluster labels for each sample.\n\n    Raises:\n        DatasetError: If `method` is 'connected_components' and no distance\n            matrix is available in the Dataset.\n        ValueError: If an unknown `method` is provided.\n    \"\"\"\n    if 'Cluster' in self._data.columns:\n        warn(\"'Cluster' column already exists and will be overwritten.\", DatasetWarning)\n\n    if method == 'variables':\n        self._data['Cluster'] = 'cluster_' + (self._data.groupby(group_by).ngroup() + 1).astype(str) \\\n            if group_by else [f'cluster_{i + 1}' for i in range(len(self._data))]\n\n    elif method == 'connected_components':\n        if self.distances is None:\n            raise DatasetError(\"Cannot calculate connected components: no distance matrix found in Dataset.\")\n\n        cluster_labels = pd.Series(index=self._data.index, dtype='object')\n        global_cluster_counter = 1\n\n        # Determine groups: either from group_by or a single group for the whole dataset\n        groups = self._data.groupby(group_by) if group_by else [('all', self._data)]\n\n        for _, group_df in groups:\n            if group_df.empty:\n                continue\n\n            # Get integer indices for samples in this group\n            group_indices = self._data.index.get_indexer(group_df.index)\n\n            # Efficiently subset the sparse graph and filter by distance\n            subgraph = self.distances[group_indices, :][:, group_indices]\n            subgraph.data[subgraph.data &gt; distance] = 0\n            subgraph.eliminate_zeros()\n\n            _, local_labels = connected_components(csgraph=subgraph, directed=False, return_labels=True)\n\n            if local_labels.size &gt; 0:\n                cluster_labels.loc[group_df.index] = [f\"cluster_{l + global_cluster_counter}\" for l in local_labels]\n                global_cluster_counter += local_labels.max() + 1\n\n        self._data['Cluster'] = cluster_labels\n\n    else:\n        raise ValueError(f\"Unknown method: {method}\")\n\n    return self._data['Cluster']\n</code></pre>"},{"location":"reference/pathogenx/dataset/#pathogenx.dataset.Dataset.from_files","title":"<code>from_files(genotypes, metadata=None, distances=None, name=None)</code>  <code>classmethod</code>","text":"<p>Initialises a <code>Dataset</code> instance from <code>_InputFile</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>genotypes</code> <code>GenotypeFile</code> <p>An instance of <code>GenotypeFile</code> containing genotype data.</p> required <code>metadata</code> <code>MetaFile</code> <p>An instance of <code>MetaFile</code> containing metadata. Defaults to None.</p> <code>None</code> <code>distances</code> <code>DistFile</code> <p>An instance of <code>DistFile</code> containing distance data. Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>A name for the dataset. Defaults to None, in which case the name will be                   inferred from the genotype file.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>cls</code> <p>A new <code>Dataset</code> instance populated with the provided data.</p> Source code in <code>pathogenx/dataset.py</code> <pre><code>@classmethod\ndef from_files(cls, genotypes: GenotypeFile, metadata: MetaFile = None, distances: DistFile = None, name: str = None):\n    \"\"\"\n    Initialises a `Dataset` instance from `_InputFile` instances.\n\n    Parameters:\n        genotypes (GenotypeFile): An instance of `GenotypeFile` containing genotype data.\n        metadata (MetaFile, optional): An instance of `MetaFile` containing metadata. Defaults to None.\n        distances (DistFile, optional): An instance of `DistFile` containing distance data. Defaults to None.\n        name (str, optional): A name for the dataset. Defaults to None, in which case the name will be\n                              inferred from the genotype file.\n\n    Returns:\n        cls: A new `Dataset` instance populated with the provided data.\n    \"\"\"\n    return cls(\n        genotypes.load(),\n        metadata.load() if metadata else None,\n        distances.load() if distances else None,\n        name\n    )\n</code></pre>"},{"location":"reference/pathogenx/dataset/#pathogenx.dataset.Dataset.from_pathogenwatch","title":"<code>from_pathogenwatch(path)</code>  <code>classmethod</code>","text":"<p>Initialises a <code>Dataset</code> instance from a Pathogenwatch folder.</p> <p>This method expects a folder containing CSV files downloaded from Pathogenwatch, specifically looking for files named according to the Pathogenwatch convention (e.g., <code>pathogenwatch-species-collection-analysis.csv</code>). It automatically identifies and loads genotype, metadata, and distance files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the directory containing Pathogenwatch CSV files.</p> required <p>Returns:</p> Name Type Description <code>Dataset</code> <code>Dataset</code> <p>A new <code>Dataset</code> instance populated with data from the Pathogenwatch files.</p> <p>Raises:</p> Type Description <code>DatasetError</code> <p>If no relevant Pathogenwatch files are found or if genotype data is missing.</p> Source code in <code>pathogenx/dataset.py</code> <pre><code>@classmethod\ndef from_pathogenwatch(cls, path: Path) -&gt; 'Dataset':\n    \"\"\"\n    Initialises a `Dataset` instance from a Pathogenwatch folder.\n\n    This method expects a folder containing CSV files downloaded from Pathogenwatch,\n    specifically looking for files named according to the Pathogenwatch convention\n    (e.g., `pathogenwatch-species-collection-analysis.csv`). It automatically\n    identifies and loads genotype, metadata, and distance files.\n\n    Parameters:\n        path (Path): The path to the directory containing Pathogenwatch CSV files.\n\n    Returns:\n        Dataset: A new `Dataset` instance populated with data from the Pathogenwatch files.\n\n    Raises:\n        DatasetError: If no relevant Pathogenwatch files are found or if genotype data is missing.\n    \"\"\"\n    r = regex(r'.*pathogenwatch-(?P&lt;species&gt;\\w+)-(?P&lt;collection&gt;[\\w-]+)-'\n              r'(?P&lt;analysis&gt;(kleborate|difference-matrix|metadata))\\.csv')\n    if not (files := [match for file in path.glob('*.csv') if (match := r.match(file.name))]):\n        raise DatasetError(f'Could not find any files in {path}')\n\n    dataset, files = next(grouper(files, 2))\n\n    files = {k: path / next(v).string for k, v in grouper(files, 3)}\n    genotypes, metadata, distances = files.get('kleborate'), files.get('metadata'), files.get('difference-matrix')\n    if genotypes is None:\n        raise DatasetError(f'Could not find any genotypes in {path} for {dataset}')\n\n    return cls.from_files(\n        GenotypeFile.from_flavour(genotypes, 'pw-kleborate'),\n        MetaFile.from_flavour(metadata, 'pw-metadata') if metadata else None,\n        DistFile.from_flavour(distances, 'pw-dist') if distances else None,\n        dataset\n    )\n</code></pre>"},{"location":"reference/pathogenx/dataset/#pathogenx.dataset.Dataset.samples","title":"<code>samples()</code>","text":"<p>Returns a list of sample names (the index of the internal DataFrame).</p> Source code in <code>pathogenx/dataset.py</code> <pre><code>def samples(self):\n    \"\"\"Returns a list of sample names (the index of the internal DataFrame).\"\"\"\n    return self._data.index\n</code></pre>"},{"location":"reference/pathogenx/io/","title":"pathogenx.io","text":"<p>Module to read and parse genotype, metadata and distance data from different sources</p>"},{"location":"reference/pathogenx/io/#pathogenx.io.DistFile","title":"<code>DistFile</code>","text":"<p>               Bases: <code>_InputFile</code></p> <p>Represents a distance matrix file.</p> Source code in <code>pathogenx/io.py</code> <pre><code>class DistFile(_InputFile):\n    \"\"\"Represents a distance matrix file.\"\"\"\n    def __init__(self, filepath: Union[Path, str], shape: Literal['square', 'long'] = 'long',\n                 sep: str = '\\t', usecols: tuple[int, int, int] = (0, 1, 2), symmetrical: bool = True):\n        \"\"\"Initializes the DistFile.\n\n        Args:\n            filepath (Union[Path, str]): The path to the distance matrix file.\n            shape (Literal['square', 'long'], optional): The shape of the matrix file.\n                'square' is a traditional matrix, 'long' is a 3-column format. Defaults to 'long'.\n            sep (str, optional): The separator used in the file. Defaults to '\\t'.\n            usecols (tuple[int, int, int], optional): The columns to use for long format\n                (sample1, sample2, distance). Defaults to (0, 1, 2).\n            symmetrical (bool, optional): Whether a square matrix is symmetrical. Defaults to True.\n        \"\"\"\n        super().__init__(filepath=filepath)\n        self.shape = shape\n        self.sep = sep\n        self.usecols = usecols\n        self.symmetrical = symmetrical\n\n    def load(self) -&gt; tuple[coo_matrix, list[str]]:\n        \"\"\"Loads a distance matrix into a sparse matrix format.\n\n        Returns:\n            tuple[coo_matrix, list[str]]: A tuple containing the sparse distance\n            matrix and a list of sample names.\n\n        Raises:\n            ValueError: If the shape is unknown.\n        \"\"\"\n        if self.shape == 'square':\n            df = pd.read_table(self.filepath, sep=self.sep, index_col=0)\n            matrix = coo_matrix(df.values)  # Convert the pandas DataFrame to a scipy sparse COO matrix\n            if not self.symmetrical:\n                matrix = matrix.maximum(matrix.T)\n            return matrix, df.columns.tolist()\n        elif self.shape == 'long':\n            df = pd.read_table(self.filepath, sep=self.sep, usecols=self.usecols, header=None)\n            index = {sample: i for i, sample in enumerate(pd.unique(df.iloc[:, [0, 1]].values.ravel('K')))}\n            num_samples = len(index)\n            rows = df.iloc[:, 0].map(index).values\n            columns = df.iloc[:, 1].map(index).values\n            data = df.iloc[:, 2].values\n            matrix = coo_matrix((data, (rows, columns)), shape=(num_samples, num_samples))\n            return matrix, list(index.keys())\n        else:\n            raise ValueError(f\"Unknown shape: {self.shape}\")\n\n    @classmethod\n    def from_flavour(cls, filepath: Union[Path, str], flavour: _DIST_FLAVOURS) -&gt; 'DistFile':\n        \"\"\"Creates a DistFile instance from a specific file format flavour.\n\n        Args:\n            filepath (Union[Path, str]): The path to the distance matrix file.\n            flavour (_DIST_FLAVOURS): The format of the file.\n\n        Returns:\n            DistFile: An instance of DistFile with appropriate settings.\n\n        Raises:\n            ValueError: If the flavour is unknown.\n        \"\"\"\n        if flavour == 'mash':\n            self = cls(filepath, shape='long', usecols=(0, 1, 3), sep='\\t')\n        elif flavour == 'ska1':\n            self = cls(filepath, shape='long', usecols=(0, 1, 6), sep='\\t')\n        elif flavour == 'ska1':\n            self = cls(filepath, shape='long', usecols=(0, 1, 2), sep='\\t')\n        elif flavour == 'pw-dist':\n            self = cls(filepath, shape='square', sep=',', symmetrical=True)\n        else:\n            raise ValueError(f\"Unknown flavour: {flavour}\")\n        return self\n</code></pre>"},{"location":"reference/pathogenx/io/#pathogenx.io.DistFile.__init__","title":"<code>__init__(filepath, shape='long', sep='\\t', usecols=(0, 1, 2), symmetrical=True)</code>","text":"<p>Initializes the DistFile.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[Path, str]</code> <p>The path to the distance matrix file.</p> required <code>shape</code> <code>Literal['square', 'long']</code> <p>The shape of the matrix file. 'square' is a traditional matrix, 'long' is a 3-column format. Defaults to 'long'.</p> <code>'long'</code> <code>sep</code> <code>str</code> <p>The separator used in the file. Defaults to '  '.</p> <code>'\\t'</code> <code>usecols</code> <code>tuple[int, int, int]</code> <p>The columns to use for long format (sample1, sample2, distance). Defaults to (0, 1, 2).</p> <code>(0, 1, 2)</code> <code>symmetrical</code> <code>bool</code> <p>Whether a square matrix is symmetrical. Defaults to True.</p> <code>True</code> Source code in <code>pathogenx/io.py</code> <pre><code>def __init__(self, filepath: Union[Path, str], shape: Literal['square', 'long'] = 'long',\n             sep: str = '\\t', usecols: tuple[int, int, int] = (0, 1, 2), symmetrical: bool = True):\n    \"\"\"Initializes the DistFile.\n\n    Args:\n        filepath (Union[Path, str]): The path to the distance matrix file.\n        shape (Literal['square', 'long'], optional): The shape of the matrix file.\n            'square' is a traditional matrix, 'long' is a 3-column format. Defaults to 'long'.\n        sep (str, optional): The separator used in the file. Defaults to '\\t'.\n        usecols (tuple[int, int, int], optional): The columns to use for long format\n            (sample1, sample2, distance). Defaults to (0, 1, 2).\n        symmetrical (bool, optional): Whether a square matrix is symmetrical. Defaults to True.\n    \"\"\"\n    super().__init__(filepath=filepath)\n    self.shape = shape\n    self.sep = sep\n    self.usecols = usecols\n    self.symmetrical = symmetrical\n</code></pre>"},{"location":"reference/pathogenx/io/#pathogenx.io.DistFile.from_flavour","title":"<code>from_flavour(filepath, flavour)</code>  <code>classmethod</code>","text":"<p>Creates a DistFile instance from a specific file format flavour.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[Path, str]</code> <p>The path to the distance matrix file.</p> required <code>flavour</code> <code>_DIST_FLAVOURS</code> <p>The format of the file.</p> required <p>Returns:</p> Name Type Description <code>DistFile</code> <code>DistFile</code> <p>An instance of DistFile with appropriate settings.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the flavour is unknown.</p> Source code in <code>pathogenx/io.py</code> <pre><code>@classmethod\ndef from_flavour(cls, filepath: Union[Path, str], flavour: _DIST_FLAVOURS) -&gt; 'DistFile':\n    \"\"\"Creates a DistFile instance from a specific file format flavour.\n\n    Args:\n        filepath (Union[Path, str]): The path to the distance matrix file.\n        flavour (_DIST_FLAVOURS): The format of the file.\n\n    Returns:\n        DistFile: An instance of DistFile with appropriate settings.\n\n    Raises:\n        ValueError: If the flavour is unknown.\n    \"\"\"\n    if flavour == 'mash':\n        self = cls(filepath, shape='long', usecols=(0, 1, 3), sep='\\t')\n    elif flavour == 'ska1':\n        self = cls(filepath, shape='long', usecols=(0, 1, 6), sep='\\t')\n    elif flavour == 'ska1':\n        self = cls(filepath, shape='long', usecols=(0, 1, 2), sep='\\t')\n    elif flavour == 'pw-dist':\n        self = cls(filepath, shape='square', sep=',', symmetrical=True)\n    else:\n        raise ValueError(f\"Unknown flavour: {flavour}\")\n    return self\n</code></pre>"},{"location":"reference/pathogenx/io/#pathogenx.io.DistFile.load","title":"<code>load()</code>","text":"<p>Loads a distance matrix into a sparse matrix format.</p> <p>Returns:</p> Type Description <code>coo_matrix</code> <p>tuple[coo_matrix, list[str]]: A tuple containing the sparse distance</p> <code>list[str]</code> <p>matrix and a list of sample names.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the shape is unknown.</p> Source code in <code>pathogenx/io.py</code> <pre><code>def load(self) -&gt; tuple[coo_matrix, list[str]]:\n    \"\"\"Loads a distance matrix into a sparse matrix format.\n\n    Returns:\n        tuple[coo_matrix, list[str]]: A tuple containing the sparse distance\n        matrix and a list of sample names.\n\n    Raises:\n        ValueError: If the shape is unknown.\n    \"\"\"\n    if self.shape == 'square':\n        df = pd.read_table(self.filepath, sep=self.sep, index_col=0)\n        matrix = coo_matrix(df.values)  # Convert the pandas DataFrame to a scipy sparse COO matrix\n        if not self.symmetrical:\n            matrix = matrix.maximum(matrix.T)\n        return matrix, df.columns.tolist()\n    elif self.shape == 'long':\n        df = pd.read_table(self.filepath, sep=self.sep, usecols=self.usecols, header=None)\n        index = {sample: i for i, sample in enumerate(pd.unique(df.iloc[:, [0, 1]].values.ravel('K')))}\n        num_samples = len(index)\n        rows = df.iloc[:, 0].map(index).values\n        columns = df.iloc[:, 1].map(index).values\n        data = df.iloc[:, 2].values\n        matrix = coo_matrix((data, (rows, columns)), shape=(num_samples, num_samples))\n        return matrix, list(index.keys())\n    else:\n        raise ValueError(f\"Unknown shape: {self.shape}\")\n</code></pre>"},{"location":"reference/pathogenx/io/#pathogenx.io.GenotypeFile","title":"<code>GenotypeFile</code>","text":"<p>               Bases: <code>_BaseTextFile</code></p> <p>Represents a genotype file.</p> Source code in <code>pathogenx/io.py</code> <pre><code>class GenotypeFile(_BaseTextFile):\n    \"\"\"Represents a genotype file.\"\"\"\n    def __init__(self, filepath: Union[Path, str], sep: str = '\\t', index_col: int = 0):\n        \"\"\"Initializes the GenotypeFile.\n\n        Args:\n            filepath (Union[Path, str]): The path to the genotype file.\n            sep (str, optional): The separator used in the file. Defaults to '\\t'.\n            index_col (int, optional): The column to use as the index. Defaults to 0.\n        \"\"\"\n        super().__init__(filepath=filepath, sep=sep, index_col=index_col)\n\n    @classmethod\n    def from_flavour(cls, filepath: Union[Path, str], flavour: _GENOTYPE_FLAVOURS) -&gt; 'GenotypeFile':\n        \"\"\"Creates a GenotypeFile instance from a specific file format flavour.\n\n        Args:\n            filepath (Union[Path, str]): The path to the genotype file.\n            flavour (_GENOTYPE_FLAVOURS): The format of the file.\n\n        Returns:\n            GenotypeFile: An instance of GenotypeFile with appropriate settings.\n\n        Raises:\n            ValueError: If the flavour is unknown.\n        \"\"\"\n        if flavour in {'kleborate', 'kaptive'}:\n            self = cls(filepath)\n        elif flavour == 'pw-kleborate':\n            self = cls(filepath, sep=',', index_col=1)\n        else:\n            raise ValueError(f\"Unknown flavour: {flavour}\")\n        return self\n</code></pre>"},{"location":"reference/pathogenx/io/#pathogenx.io.GenotypeFile.__init__","title":"<code>__init__(filepath, sep='\\t', index_col=0)</code>","text":"<p>Initializes the GenotypeFile.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[Path, str]</code> <p>The path to the genotype file.</p> required <code>sep</code> <code>str</code> <p>The separator used in the file. Defaults to '  '.</p> <code>'\\t'</code> <code>index_col</code> <code>int</code> <p>The column to use as the index. Defaults to 0.</p> <code>0</code> Source code in <code>pathogenx/io.py</code> <pre><code>def __init__(self, filepath: Union[Path, str], sep: str = '\\t', index_col: int = 0):\n    \"\"\"Initializes the GenotypeFile.\n\n    Args:\n        filepath (Union[Path, str]): The path to the genotype file.\n        sep (str, optional): The separator used in the file. Defaults to '\\t'.\n        index_col (int, optional): The column to use as the index. Defaults to 0.\n    \"\"\"\n    super().__init__(filepath=filepath, sep=sep, index_col=index_col)\n</code></pre>"},{"location":"reference/pathogenx/io/#pathogenx.io.GenotypeFile.from_flavour","title":"<code>from_flavour(filepath, flavour)</code>  <code>classmethod</code>","text":"<p>Creates a GenotypeFile instance from a specific file format flavour.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[Path, str]</code> <p>The path to the genotype file.</p> required <code>flavour</code> <code>_GENOTYPE_FLAVOURS</code> <p>The format of the file.</p> required <p>Returns:</p> Name Type Description <code>GenotypeFile</code> <code>GenotypeFile</code> <p>An instance of GenotypeFile with appropriate settings.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the flavour is unknown.</p> Source code in <code>pathogenx/io.py</code> <pre><code>@classmethod\ndef from_flavour(cls, filepath: Union[Path, str], flavour: _GENOTYPE_FLAVOURS) -&gt; 'GenotypeFile':\n    \"\"\"Creates a GenotypeFile instance from a specific file format flavour.\n\n    Args:\n        filepath (Union[Path, str]): The path to the genotype file.\n        flavour (_GENOTYPE_FLAVOURS): The format of the file.\n\n    Returns:\n        GenotypeFile: An instance of GenotypeFile with appropriate settings.\n\n    Raises:\n        ValueError: If the flavour is unknown.\n    \"\"\"\n    if flavour in {'kleborate', 'kaptive'}:\n        self = cls(filepath)\n    elif flavour == 'pw-kleborate':\n        self = cls(filepath, sep=',', index_col=1)\n    else:\n        raise ValueError(f\"Unknown flavour: {flavour}\")\n    return self\n</code></pre>"},{"location":"reference/pathogenx/io/#pathogenx.io.MetaFile","title":"<code>MetaFile</code>","text":"<p>               Bases: <code>_BaseTextFile</code></p> <p>Represents a metadata file.</p> Source code in <code>pathogenx/io.py</code> <pre><code>class MetaFile(_BaseTextFile):\n    \"\"\"Represents a metadata file.\"\"\"\n    def __init__(self, filepath: Union[Path, str], sep: str = '\\t', index_col: int = 0):\n        \"\"\"Initializes the MetaFile.\n\n        Args:\n            filepath (Union[Path, str]): The path to the metadata file.\n            sep (str, optional): The separator used in the file. Defaults to '\\t'.\n            index_col (int, optional): The column to use as the index. Defaults to 0.\n        \"\"\"\n        super().__init__(filepath=filepath, sep=sep, index_col=index_col)\n\n    @classmethod\n    def from_flavour(cls, filepath: Union[Path, str], flavour: _META_FLAVOURS) -&gt; 'MetaFile':\n        \"\"\"Creates a MetaFile instance from a specific file format flavour.\n\n        Args:\n            filepath (Union[Path, str]): The path to the metadata file.\n            flavour (_META_FLAVOURS): The format of the file.\n\n        Returns:\n            MetaFile: An instance of MetaFile with appropriate settings.\n\n        Raises:\n            ValueError: If the flavour is unknown.\n        \"\"\"\n        if flavour == 'pw-metadata':\n            self = cls(filepath, sep=',')\n        else:\n            raise ValueError(f\"Unknown flavour: {flavour}\")\n        return self\n</code></pre>"},{"location":"reference/pathogenx/io/#pathogenx.io.MetaFile.__init__","title":"<code>__init__(filepath, sep='\\t', index_col=0)</code>","text":"<p>Initializes the MetaFile.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[Path, str]</code> <p>The path to the metadata file.</p> required <code>sep</code> <code>str</code> <p>The separator used in the file. Defaults to '  '.</p> <code>'\\t'</code> <code>index_col</code> <code>int</code> <p>The column to use as the index. Defaults to 0.</p> <code>0</code> Source code in <code>pathogenx/io.py</code> <pre><code>def __init__(self, filepath: Union[Path, str], sep: str = '\\t', index_col: int = 0):\n    \"\"\"Initializes the MetaFile.\n\n    Args:\n        filepath (Union[Path, str]): The path to the metadata file.\n        sep (str, optional): The separator used in the file. Defaults to '\\t'.\n        index_col (int, optional): The column to use as the index. Defaults to 0.\n    \"\"\"\n    super().__init__(filepath=filepath, sep=sep, index_col=index_col)\n</code></pre>"},{"location":"reference/pathogenx/io/#pathogenx.io.MetaFile.from_flavour","title":"<code>from_flavour(filepath, flavour)</code>  <code>classmethod</code>","text":"<p>Creates a MetaFile instance from a specific file format flavour.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[Path, str]</code> <p>The path to the metadata file.</p> required <code>flavour</code> <code>_META_FLAVOURS</code> <p>The format of the file.</p> required <p>Returns:</p> Name Type Description <code>MetaFile</code> <code>MetaFile</code> <p>An instance of MetaFile with appropriate settings.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the flavour is unknown.</p> Source code in <code>pathogenx/io.py</code> <pre><code>@classmethod\ndef from_flavour(cls, filepath: Union[Path, str], flavour: _META_FLAVOURS) -&gt; 'MetaFile':\n    \"\"\"Creates a MetaFile instance from a specific file format flavour.\n\n    Args:\n        filepath (Union[Path, str]): The path to the metadata file.\n        flavour (_META_FLAVOURS): The format of the file.\n\n    Returns:\n        MetaFile: An instance of MetaFile with appropriate settings.\n\n    Raises:\n        ValueError: If the flavour is unknown.\n    \"\"\"\n    if flavour == 'pw-metadata':\n        self = cls(filepath, sep=',')\n    else:\n        raise ValueError(f\"Unknown flavour: {flavour}\")\n    return self\n</code></pre>"},{"location":"reference/pathogenx/models/","title":"pathogenx.models","text":"<p>Module for defining statistical models to work with <code>pathogenx.calculator.Calculator</code>s</p>"},{"location":"reference/pathogenx/models/#pathogenx.models.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for statistical models.</p> Source code in <code>pathogenx/models.py</code> <pre><code>class Model(ABC):\n    \"\"\"\n    Abstract base class for statistical models.\n    \"\"\"\n\n    @abstractmethod\n    def fit(self, dataset: Dataset) -&gt; ModelResult:\n        \"\"\"Fits the model using the supplied dataset\"\"\"\n        pass\n</code></pre>"},{"location":"reference/pathogenx/models/#pathogenx.models.Model.fit","title":"<code>fit(dataset)</code>  <code>abstractmethod</code>","text":"<p>Fits the model using the supplied dataset</p> Source code in <code>pathogenx/models.py</code> <pre><code>@abstractmethod\ndef fit(self, dataset: Dataset) -&gt; ModelResult:\n    \"\"\"Fits the model using the supplied dataset\"\"\"\n    pass\n</code></pre>"},{"location":"reference/pathogenx/models/#pathogenx.models.ModelResult","title":"<code>ModelResult</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for model results, designed such that we can infer the parameters of the model used to generate the result, without needing the instance itself.</p> Source code in <code>pathogenx/models.py</code> <pre><code>class ModelResult(ABC):\n    \"\"\"\n    Abstract base class for model results, designed such that we can infer the parameters of the model\n    used to generate the result, without needing the instance itself.\n    \"\"\"\n\n    def __init__(self):\n        self._data = None\n\n    @property\n    def data(self) -&gt; pd.DataFrame:\n        \"\"\"Returns a copy of the result data to prevent accidental modification.\"\"\"\n        return self._data.copy() if self._data is not None else pd.DataFrame()\n\n    @data.setter\n    def data(self, value: pd.DataFrame):\n        \"\"\"Sets the result data stored as a private property\"\"\"\n        self._data = value\n\n    def __len__(self):\n        \"\"\"Returns the length of the result data\"\"\"\n        return 0 if self._data is None else len(self._data)\n\n    @abstractmethod\n    def save(self, filepath: Path):\n        \"\"\"Saves the model result to a file for future use\"\"\"\n        pass\n\n    @classmethod\n    @abstractmethod\n    def from_file(cls, filepath: Path):\n        \"\"\"Loads the model result from a file into memory\"\"\"\n        pass\n</code></pre>"},{"location":"reference/pathogenx/models/#pathogenx.models.ModelResult.data","title":"<code>data</code>  <code>property</code> <code>writable</code>","text":"<p>Returns a copy of the result data to prevent accidental modification.</p>"},{"location":"reference/pathogenx/models/#pathogenx.models.ModelResult.__len__","title":"<code>__len__()</code>","text":"<p>Returns the length of the result data</p> Source code in <code>pathogenx/models.py</code> <pre><code>def __len__(self):\n    \"\"\"Returns the length of the result data\"\"\"\n    return 0 if self._data is None else len(self._data)\n</code></pre>"},{"location":"reference/pathogenx/models/#pathogenx.models.ModelResult.from_file","title":"<code>from_file(filepath)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Loads the model result from a file into memory</p> Source code in <code>pathogenx/models.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_file(cls, filepath: Path):\n    \"\"\"Loads the model result from a file into memory\"\"\"\n    pass\n</code></pre>"},{"location":"reference/pathogenx/models/#pathogenx.models.ModelResult.save","title":"<code>save(filepath)</code>  <code>abstractmethod</code>","text":"<p>Saves the model result to a file for future use</p> Source code in <code>pathogenx/models.py</code> <pre><code>@abstractmethod\ndef save(self, filepath: Path):\n    \"\"\"Saves the model result to a file for future use\"\"\"\n    pass\n</code></pre>"},{"location":"reference/pathogenx/utils/","title":"pathogenx.utils","text":""},{"location":"reference/pathogenx/utils/#pathogenx.utils.bold","title":"<code>bold(string)</code>","text":"<p>Returns the string in bold</p> Source code in <code>pathogenx/utils.py</code> <pre><code>def bold(string: str) -&gt; str:\n    \"\"\"Returns the string in bold\"\"\"\n    return f\"\\033[1m{string}\\033[0m\"\n</code></pre>"},{"location":"reference/pathogenx/utils/#pathogenx.utils.grouper","title":"<code>grouper(iterable, key)</code>","text":"<p>Shortcut for sorting and grouping</p> Source code in <code>pathogenx/utils.py</code> <pre><code>def grouper(iterable: Iterable, key: Union[str, int]):\n    \"\"\"Shortcut for sorting and grouping\"\"\"\n    getter = attrgetter(key) if isinstance(key, str) else itemgetter(key)\n    yield from groupby(sorted(iterable, key=getter), key=getter)\n</code></pre>"}]}